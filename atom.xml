<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HUA Blog</title>
  
  <subtitle>HUA家博客</subtitle>
  <link href="https://blog.kdyx.net/atom.xml" rel="self"/>
  
  <link href="https://blog.kdyx.net/"/>
  <updated>2024-04-04T03:53:39.524Z</updated>
  <id>https://blog.kdyx.net/</id>
  
  <author>
    <name>HUA Blog</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>保姆级毛发算法调研分析，十万长文带你深入TressFX（三）</title>
    <link href="https://blog.kdyx.net/blog/kongdeyou/hair_simulation_and_rendering_3/"/>
    <id>https://blog.kdyx.net/blog/kongdeyou/hair_simulation_and_rendering_3/</id>
    <published>2022-06-22T15:33:58.000Z</published>
    <updated>2024-04-04T03:53:39.524Z</updated>
    
    <content type="html"><![CDATA[<h1 id="毛发发丝的碰撞矫正"><a href="#毛发发丝的碰撞矫正" class="headerlink" title="毛发发丝的碰撞矫正"></a>毛发发丝的碰撞矫正</h1><p>本文仅在个人博客及个人知乎上采用”CC BY-NC-ND 4.0”(署名-不可商用-禁止演绎)协议发布，转载请注明个人博客的原文链接及作者信息，侵权必究。</p><p>博客链接：<a href="https://tis.ac.cn/blog/kongdeyou/hair_simulation_and_rendering_3/">https://tis.ac.cn/blog/kongdeyou/hair_simulation_and_rendering_3/</a></p><p>知乎链接：<a href="https://zhuanlan.zhihu.com/p/534732852/">https://zhuanlan.zhihu.com/p/534732852/</a></p><p>本文将主要分析TressFX毛发系统中物理模拟的碰撞矫正，目录结构如下：</p><p>[toc]</p><h2 id="碰撞矫正"><a href="#碰撞矫正" class="headerlink" title="碰撞矫正"></a>碰撞矫正</h2><p>碰撞矫正由两个部分组成：用与头发待碰撞的物体建立有向距离场，然后再用前面的发丝物理计算结果在这个有向距离场中做碰撞检测和矫正。</p><h3 id="碰撞检测使用的有向距离场"><a href="#碰撞检测使用的有向距离场" class="headerlink" title="碰撞检测使用的有向距离场"></a>碰撞检测使用的有向距离场</h3><p>针对场景中每个需要与头发进行碰撞检测的物体（比如玩家角色的头颅模型），均需要2个passes，第一个pass用来处理该物体的骨骼动画，第二个pass用来建场，建场又由3个subpasses组成。</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/TressFX_03.png" alt="BoneSkin与SDF的Pass图"></p><p>处理骨骼动画的pass和一般骨骼动画的处理逻辑的思路是一样的，输入T-Pose下的vertex attributes和vertex bone indices and bone weights，通过constant buffer送下去所有bones的inverse bind matrices，然后算出受骨骼动画驱动后的vertex attributes。只不过，这里的骨骼计算和普通的骨骼计算流程不太相同，TressFX的maya导出工具会将用于碰撞检测的物体的数据存储到tfxmesh文件中，tfxmesh存储了vertex position&#x2F;normal和bone indices&#x2F;weights数据，此处会使用tfxmesh文件中记录的这些数据作为碰撞检测的mesh数据，因此我们的数据来源来自于tfxmesh文件（多了这个步骤后，我们就能够建一个很复杂的有很多面片数的人头模型，再做一个这个人头模型的低模，这样在渲染的时候使用高模，导给头发系统处理时使用低模，这样可以大大减少在做碰撞检测时的计算量，还能基本保证不穿模）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">骨骼计算，略，详见：https://github.com/GPUOpen-Effects/TressFX/blob/v4.1.0/src/Shaders/TressFXBoneSkinning.hlsl#L24-L94</span><br></pre></td></tr></table></figure><p>建场过程由InitializeSignedDistanceField、ConstructSignedDistanceField、FinalizeSignedDistanceField三个subpass组成。</p><p>SDF使用物体的扩展包围盒来建立一个正方体的晶胞盒。</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/TressFX_Doc_09.jpg" alt="正方体晶胞盒"></p><p>然后将物体模型放在这个晶胞盒中，逐三角形遍历临近的晶胞，计算晶胞的中心点到三角形的最小距离，作为该晶胞的值。如果晶胞中心在物体模型内，即晶胞中心指向三角形的内侧，则距离符号为负；如果在物体模型外，则距离符号为正；如果超过一定距离（即非三角形临近的晶胞），将该晶胞的值记为同一个最大值（INITIAL_DISTANCE，值为1e10f）。</p><p>InitializeSignedDistanceField做初始化这个晶胞盒的操作，会将所有的晶胞置为一个最大值，如下代码所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// One thread for each cell.</span><br><span class="line">[numthreads(THREAD_GROUP_SIZE, 1, 1)]</span><br><span class="line">void InitializeSignedDistanceField(uint GIndex : SV_GroupIndex,</span><br><span class="line">    uint3 GId : SV_GroupID, uint3 DTid : SV_DispatchThreadID)</span><br><span class="line">&#123;</span><br><span class="line">    int numSdfCells = g_NumCellsX * g_NumCellsY * g_NumCellsZ; // 总晶胞数</span><br><span class="line"></span><br><span class="line">    int sdfCellIndex = GId.x * THREAD_GROUP_SIZE + GIndex; // 当前的线程所负责的晶胞</span><br><span class="line">    if(sdfCellIndex &gt;= numSdfCells) return;</span><br><span class="line"></span><br><span class="line">    g_SignedDistanceField[sdfCellIndex] = FloatFlip3(INITIAL_DISTANCE); // 初始化当前线程所负责的晶胞记录的值为最大值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处注意到，g_SignedDistanceField这个变量是个uint数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[vk::binding(1, 0)]] RWStructuredBuffer&lt;uint&gt; g_SignedDistanceField : register(u1, space0);</span><br></pre></td></tr></table></figure><p>这里TressFX没有直接使用float类型，因为为了节省计算量，TressFX采用的是逐三角形遍历<strong>临近的</strong>晶胞的方法，而不是逐晶胞遍历物体模型的逐三角形，这个过程在GPU中执行，那么就有可能发生两个三角形共同影响同一个晶胞，而两个三角形分别在两个线程中执行，于是在这个晶胞上就会出现读写冲突，为了使用GPU中的原子化比较写入函数InterlockedMin（该函数只能用在uint和int类型上），TressFX得把浮点转成整型，这个过程可以通过HLSL的asuint或asint函数实现。TressFX此处用了asuint，由于asuint之后，得到的是一个无符号的整数值，因此TressFX写了两个函数FloatFlip3和IFloatFlip3，计算得到SDF的晶胞值后用FloatFlip3存下来，此时会把符号位从最高位移动到最低位，避免符号位对值的大小产生影响，这样其他三角形计算出来的结果和该晶胞上的值比较时，不会因为uint导致负数变成大正数，无论正负都是同一种比较方法，在计算完所有三角形得出所有的晶胞值后，再逐晶胞调用IFloatFlip3把符号恢复回来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">uint FloatFlip3(float fl)</span><br><span class="line">&#123;</span><br><span class="line">    uint f = asuint(fl);</span><br><span class="line">    return (f &lt;&lt; 1) | (f &gt;&gt; 31); // Rotate sign bit to least significant</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint IFloatFlip3(uint f2)</span><br><span class="line">&#123;</span><br><span class="line">    return (f2 &gt;&gt; 1) | (f2 &lt;&lt; 31); // Restore the sign bit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConstructSignedDistanceField会逐三角形遍历临近的晶胞，构造出当前物体模型的有向距离场。</p><p>collMeshVertexPositions由前面的处理骨骼的pass输出，作为当前pass的输入。g_TrimeshVertexIndices存储了当前物体模型的三角形索引数据，primitive topology是triangle list。这些在pass图中均有展示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//Triangle input to SDF builder</span><br><span class="line">[[vk::binding(0, 0)]] StructuredBuffer&lt;uint&gt; g_TrimeshVertexIndices : register(t0, space0);</span><br><span class="line">[[vk::binding(2, 0)]] RWStructuredBuffer&lt;StandardVertex&gt; collMeshVertexPositions : register(u2, space0);</span><br></pre></td></tr></table></figure><p>在shader中，每一个三角形一个线程，先计算出三角形的AABB包围盒，然后根据AABB包围盒对应算出所占据的晶胞盒子集，计算出三角形到这个子集内的晶胞们的中心的距离，作为这些晶胞们的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// One thread per each triangle</span><br><span class="line">[numthreads(THREAD_GROUP_SIZE, 1, 1)]</span><br><span class="line">void ConstructSignedDistanceField(uint GIndex : SV_GroupIndex,</span><br><span class="line">    uint3 GId : SV_GroupID, uint3 DTid : SV_DispatchThreadID)</span><br><span class="line">&#123;</span><br><span class="line">    int triangleIndex = GId.x * THREAD_GROUP_SIZE + GIndex;</span><br><span class="line"></span><br><span class="line">    uint numTriangleIndices, stride;</span><br><span class="line">    g_TrimeshVertexIndices.GetDimensions(numTriangleIndices, stride);</span><br><span class="line">    uint numTriangles = numTriangleIndices / 3;</span><br><span class="line"></span><br><span class="line">    if (triangleIndex &gt;= (int)numTriangles)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    // 取得当前待处理的三角形的索引</span><br><span class="line">    uint index0 = g_TrimeshVertexIndices[triangleIndex * 3 + 0];</span><br><span class="line">    uint index1 = g_TrimeshVertexIndices[triangleIndex * 3 + 1];</span><br><span class="line">    uint index2 = g_TrimeshVertexIndices[triangleIndex * 3 + 2];</span><br><span class="line"></span><br><span class="line">    // 取得当前待处理的三角形的顶点位置</span><br><span class="line">    float3 tri0 = collMeshVertexPositions[index0].position;</span><br><span class="line">    float3 tri1 = collMeshVertexPositions[index1].position;</span><br><span class="line">    float3 tri2 = collMeshVertexPositions[index2].position;</span><br><span class="line"></span><br><span class="line">    // 算出三角形的AABB包围盒</span><br><span class="line">    float3 aabbMin = min(tri0, min(tri1, tri2)) - float3(MARGIN, MARGIN, MARGIN); // #define MARGIN g_CellSize</span><br><span class="line">    float3 aabbMax = max(tri0, max(tri1, tri2)) + float3(MARGIN, MARGIN, MARGIN); // 包围盒扩展一个晶胞的长度大小</span><br><span class="line"></span><br><span class="line">    // 根据AABB包围盒得到晶胞盒子集，AABB包围盒是float位置数据，此处算出对应的对角轴晶胞的ID</span><br><span class="line">    int3 gridMin = GetSdfCoordinates(aabbMin) - GRID_MARGIN; // #define GRID_MARGIN int3(1, 1, 1)</span><br><span class="line">    int3 gridMax = GetSdfCoordinates(aabbMax) + GRID_MARGIN; // 晶胞盒子集向外扩展一个晶胞</span><br><span class="line"></span><br><span class="line">    // 经过上面将三角形包围盒所占据的晶胞向外延展之后，相当于我们找出了三角形临近的晶胞</span><br><span class="line">    // 然后我们将这些临近的晶胞限制在有效的范围内</span><br><span class="line">    gridMin.x = max(0, min(gridMin.x, g_NumCellsX - 1));</span><br><span class="line">    gridMin.y = max(0, min(gridMin.y, g_NumCellsY - 1));</span><br><span class="line">    gridMin.z = max(0, min(gridMin.z, g_NumCellsZ - 1));</span><br><span class="line">    gridMax.x = max(0, min(gridMax.x, g_NumCellsX - 1));</span><br><span class="line">    gridMax.y = max(0, min(gridMax.y, g_NumCellsY - 1));</span><br><span class="line">    gridMax.z = max(0, min(gridMax.z, g_NumCellsZ - 1));</span><br><span class="line"></span><br><span class="line">    // 针对每个临近的晶胞，计算其中心到三角形的距离，取绝对值的最小值存为该晶胞的值，即SDF中该小立方格子的值</span><br><span class="line">    for (int z = gridMin.z; z &lt;= gridMax.z; ++z)</span><br><span class="line">        for (int y = gridMin.y; y &lt;= gridMax.y; ++y)</span><br><span class="line">            for (int x = gridMin.x; x &lt;= gridMax.x; ++x)</span><br><span class="line">            &#123;</span><br><span class="line">                int3 gridCellCoordinate = int3(x, y, z);</span><br><span class="line">                int gridCellIndex = GetSdfCellIndex(gridCellCoordinate);</span><br><span class="line">                float3 cellPosition = GetSdfCellPosition(gridCellCoordinate);</span><br><span class="line"></span><br><span class="line">                float distance = SignedDistancePointToTriangle(cellPosition, tri0, tri1, tri2);</span><br><span class="line">                uint distanceAsUint = FloatFlip3(distance);</span><br><span class="line">                InterlockedMin(g_SignedDistanceField[gridCellIndex], distanceAsUint);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中：GetSdfCoordinates根据场景中的点找到该位置所在的晶胞，晶胞相对于从g_Origin位置所在的坐标开始，有g_NumCellsX&#x2F;Y&#x2F;Z个，单个晶胞大小为g_CellSize，覆盖了场景中的g_Origin至(g_Origin+g_CellSize*vec3(g_NumCellsX,g_NumCellsY,g_NumCellsZ))的空间范围；GetSdfCellIndex和GetSdfCellPosition分别获取当前晶胞在g_SignedDistanceField数组中的索引和获取晶胞在场景中的中心位置，然后SignedDistancePointToTriangle计算出到三角形的距离，最后用InterlockedMin原子写入晶胞数组的指定位置中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">int3 GetSdfCoordinates(float3 positionInWorld)</span><br><span class="line">&#123;</span><br><span class="line">    // g_Origin是整个晶胞盒在场景的世界坐标系下的偏移，减去后是相对于以g_Origin为原点的坐标系的相对坐标</span><br><span class="line">    float3 sdfPosition = (positionInWorld - g_Origin.xyz) / g_CellSize;</span><br><span class="line"></span><br><span class="line">    int3 result;</span><br><span class="line">    result.x = (int)sdfPosition.x;</span><br><span class="line">    result.y = (int)sdfPosition.y;</span><br><span class="line">    result.z = (int)sdfPosition.z;</span><br><span class="line"></span><br><span class="line">    return result; // Get SDF cell index coordinates (x, y and z) from a point position in world space</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int GetSdfCellIndex(int3 gridPosition)</span><br><span class="line">&#123;</span><br><span class="line">    int cellsPerLine = g_NumCellsX;</span><br><span class="line">    int cellsPerPlane = g_NumCellsX * g_NumCellsY;</span><br><span class="line"></span><br><span class="line">    return cellsPerPlane*gridPosition.z + cellsPerLine*gridPosition.y + gridPosition.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float3 GetSdfCellPosition(int3 gridPosition)</span><br><span class="line">&#123;</span><br><span class="line">    float3 cellCenter = float3(gridPosition.x, gridPosition.y, gridPosition.z) * g_CellSize; // 相对位置，晶胞盒内的局部坐标</span><br><span class="line">    cellCenter += g_Origin.xyz; // g_Origin是整个晶胞盒在场景的世界坐标系下的偏移，加上后取得世界坐标，三角形的三个顶点的坐标是在世界坐标系下的</span><br><span class="line"></span><br><span class="line">    return cellCenter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float SignedDistancePointToTriangle(float3 p, float3 x0, float3 x1, float3 x2) // 晶胞中心点到三角形的距离</span><br><span class="line">&#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;   // 几何数学计算，略，详见：https://github.com/GPUOpen-Effects/TressFX/blob/v4.1.0/src/Shaders/TressFXSDFCollision.hlsl#L147-L215</span><br></pre></td></tr></table></figure><p>最后FinalizeSignedDistanceField将晶胞盒的所有晶胞的正负符号恢复回来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// One thread per each cell.</span><br><span class="line">[numthreads(THREAD_GROUP_SIZE, 1, 1)]</span><br><span class="line">void FinalizeSignedDistanceField(uint GIndex : SV_GroupIndex,</span><br><span class="line">    uint3 GId : SV_GroupID, uint3 DTid : SV_DispatchThreadID)</span><br><span class="line">&#123;</span><br><span class="line">    int numSdfCells = g_NumCellsX * g_NumCellsY * g_NumCellsZ;</span><br><span class="line"></span><br><span class="line">    int sdfCellIndex = GId.x * THREAD_GROUP_SIZE + GIndex;</span><br><span class="line">    if (sdfCellIndex &gt;= numSdfCells) return;</span><br><span class="line"></span><br><span class="line">    uint distance = g_SignedDistanceField[sdfCellIndex];</span><br><span class="line">    g_SignedDistanceField[sdfCellIndex] = IFloatFlip3(distance); // IFloatFlip3将符号位恢复回来</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上的计算中，我们使用了g_Origin、g_CellSize、g_NumCellsX&#x2F;Y&#x2F;Z这些值，它们来自于Constant Buffer。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[[vk::binding(3, 0)]] cbuffer ConstBuffer_SDF : register(b3, space0)</span><br><span class="line">&#123;</span><br><span class="line">    float4 g_Origin;  // 晶胞盒局部坐标系的坐标轴在世界坐标系下的位置</span><br><span class="line">    float g_CellSize; // 一个晶胞的单位长度</span><br><span class="line">    int g_NumCellsX;  // X轴晶胞个数</span><br><span class="line">    int g_NumCellsY;  // Y轴晶胞个数</span><br><span class="line">    int g_NumCellsZ;  // Z轴晶胞个数</span><br><span class="line">    // 以下的参数目前均没有使用</span><br><span class="line">    int g_MaxMarchingCubesVertices; // 这个变量全局都没有使用的地方，是废弃的</span><br><span class="line">    float g_MarchingCubesIsolevel;  // 这个变量全局都没有使用的地方，也是废弃的</span><br><span class="line">    float g_CollisionMargin;</span><br><span class="line">    int g_NumHairVerticesPerStrand;</span><br><span class="line">    int g_NumTotalHairVertices;</span><br><span class="line">    float pad1;</span><br><span class="line">    float pad2;</span><br><span class="line">    float pad3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C++代码中该结构体定义在TressFXConstantBuffers.h头文件中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TressFXSDFCollisionParams</span></span><br><span class="line">&#123;</span><br><span class="line">    AMD::float4  m_Origin;</span><br><span class="line">    <span class="type">float</span>        m_CellSize;</span><br><span class="line">    <span class="type">int</span>          m_NumCellsX;</span><br><span class="line">    <span class="type">int</span>          m_NumCellsY;</span><br><span class="line">    <span class="type">int</span>          m_NumCellsZ;</span><br><span class="line">    <span class="type">int</span>          m_MaxMarchingCubesVertices;</span><br><span class="line">    <span class="type">float</span>        m_MarchingCubesIsolevel;</span><br><span class="line">    <span class="type">float</span>        m_CollisionMargin;</span><br><span class="line">    <span class="type">int</span>          m_NumHairVerticesPerStrand;</span><br><span class="line">    <span class="type">int</span>          m_NumTotalHairVertices;</span><br><span class="line">    <span class="type">float</span>        pad1;</span><br><span class="line">    <span class="type">float</span>        pad2;</span><br><span class="line">    <span class="type">float</span>        pad3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>拿着TressFXSDFCollisionParams逐步反向查找，TressFXSDFCollision类中存在该结构体的实例变量m_ConstBuffer，该变量值在TressFXSDFCollision类函数Update或CollideWithHair中更改。</p><blockquote><p><strong>TressFX此处的实现有缺陷</strong>，已向开源仓反馈，缺陷详见：<a href="https://github.com/GPUOpen-Effects/TressFX/issues/46">https://github.com/GPUOpen-Effects/TressFX/issues/46</a><br>在创建SDF的pass中，由于g_MaxMarchingCubesVertices、g_MarchingCubesIsolevel、g_CollisionMargin、g_NumHairVerticesPerStrand、g_NumTotalHairVertices变量没有使用，因此不会出现问题。但是在后面的发丝碰撞矫正的pass中，会使用到g_CollisionMargin、g_NumHairVerticesPerStrand、g_NumTotalHairVertices，而这些数据是头发相关的数据（非有向距离场信息数据），它们是同一块ConstBuffer，TressFXSDFCollision::CollideWithHair在下发这个ConstBuffer时一把下发下去了，导致最后一个头发模型的数据覆盖掉了前面其他头发模型的数据。</p></blockquote><blockquote><p>此处应该分成两个结构体来实现：<code>TressFXSDFCollisionCollidee</code>和<code>TressFXSDFCollisionCollider</code>，即</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TressFXSDFCollisionCollidee</span></span><br><span class="line">&#123;</span><br><span class="line">    AMD::float4 m_Origin;</span><br><span class="line">    <span class="type">float</span>       m_CellSize;</span><br><span class="line">    <span class="type">int</span>         m_NumCellsX;</span><br><span class="line">    <span class="type">int</span>         m_NumCellsY;</span><br><span class="line">    <span class="type">int</span>         m_NumCellsZ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TressFXSDFCollisionCollider</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> m_CollisionMargin;</span><br><span class="line">    <span class="type">int</span>   m_NumHairVerticesPerStrand;</span><br><span class="line">    <span class="type">int</span>   m_NumTotalHairVertices;</span><br><span class="line">    <span class="comment">// padding...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>针对每一个SDF（头发模型要与之碰撞的物体模型）都下发各自的TressFXSDFCollisionCollidee，而针对每一个头发模型都下发各自的TressFXSDFCollisionCollider。这样就能解掉上面的bug，而且逻辑更清晰。</p></blockquote><p>在TressFXSDFCollision构造函数中初始化影响m_ConstBuffer值的相关量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize SDF grid using the associated model&#x27;s bounding box</span></span><br><span class="line">    Vector3 bmin, bmax;</span><br><span class="line">    m_pInputCollisionMesh-&gt;<span class="built_in">GetInitialBoundingBox</span>(bmin, bmax);</span><br><span class="line">    m_CellSize = (bmax.x - bmin.x) / m_NumCellsInXAxis;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> numExtraPaddingCells = (<span class="type">int</span>)(<span class="number">0.8f</span> * (<span class="type">float</span>)m_NumCellsInXAxis);</span><br><span class="line">    m_PaddingBoundary = numExtraPaddingCells * m_CellSize;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UpdateSDFGrid</span>(bmin, bmax); <span class="comment">// 该函数内会设置m_Origin为扩展后的包围盒：bmin-m_PaddingBoundary</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩展包围盒，(int)(float/int)的操作会去尾，扩展后变成进一</span></span><br><span class="line">    bmin -= m_PaddingBoundary;</span><br><span class="line">    bmax += m_PaddingBoundary;</span><br><span class="line">    m_NumCellsX = (<span class="type">int</span>)((bmax.x - bmin.x) / m_CellSize);</span><br><span class="line">    m_NumCellsY = (<span class="type">int</span>)((bmax.y - bmin.y) / m_CellSize);</span><br><span class="line">    m_NumCellsZ = (<span class="type">int</span>)((bmax.z - bmin.z) / m_CellSize);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中m_NumCellsInXAxis从构造函数的入参中来，而构造TressFXSDFCollision在CollisionMesh的构造函数中，依次向上找，该值存在于TressFXCollisionMeshDescription结构体的numCellsInXAxis中。而该结构体数组又存在于TressFXSceneDescription的collisionMeshes中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// From TressFXSample.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TressFXCollisionMeshDescription</span></span><br><span class="line">&#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    std::string tfxMeshFilePath;</span><br><span class="line">    <span class="type">int</span>         numCellsInXAxis; <span class="comment">// 每个轴方向上的晶胞个数，该值会影响每个晶胞的大小，该值越大晶胞单位长度越小，计算量越多，碰撞矫正越精细</span></span><br><span class="line">    <span class="type">float</span>       collisionMargin; <span class="comment">// 碰撞余量，在创建SDF时没有使用，会在发丝碰撞矫正时使用</span></span><br><span class="line">    <span class="type">int</span>         mesh;</span><br><span class="line">    std::string followBone;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TressFXSceneDescription</span></span><br><span class="line">&#123; <span class="comment">// TressFX中的Demo定义的该结构体存储了整个Sample场景中的所有素材数据，集成进引擎中时</span></span><br><span class="line">  <span class="comment">// 需要调整成我们自己的数据结构，用来存储头发和会和头发产生碰撞的物体模型的数据！！</span></span><br><span class="line">    std::vector&lt;TressFXObjectDescription&gt;        objects;</span><br><span class="line">    std::vector&lt;TressFXCollisionMeshDescription&gt; collisionMeshes;</span><br><span class="line"></span><br><span class="line">    std::string gltfFilePath;</span><br><span class="line">    std::string gltfFileName;</span><br><span class="line">    std::string gltfBonePrefix;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> startOffset;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再往上追溯，就到了<code>TressFXSample.cpp</code>中的<a href="https://github.com/GPUOpen-Effects/TressFX/blob/v4.1.0/src/TressFXSample.cpp#L499-L529">TressFXSample::LoadScene</a>函数实现中了。该参数的设置来源于sample中。即，该参数需要来源于外部配置。因此，我们集成进自己的引擎中时，需要在Editor的Inspector面板上暴露UI给技美，让技美选择头发需要做碰撞检测的物体模型(.tfxmesh)和生成SDF时所使用的相关的参数。</p><h3 id="基于有向距离场的发丝碰撞矫正"><a href="#基于有向距离场的发丝碰撞矫正" class="headerlink" title="基于有向距离场的发丝碰撞矫正"></a>基于有向距离场的发丝碰撞矫正</h3><p>针对一个头发所关联的每个SDF，都需要一个Pass来做一次碰撞矫正，我们给这个Pass输入SDF和经过物理动力学和风场计算后的发丝位置，经过矫正后输出在碰撞体外的发丝顶点新位置，这个新位置将作为整个发丝物理计算后的最终位置，用于后续的渲染中，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/TressFX_10.png" alt="碰撞矫正Pass图"></p><p>矫正的算法并不复杂：在前一小节中，我们已经生成了待碰撞体的有向距离场，而发丝顶点会在这个距离场中，我们根据发丝顶点所处的晶胞位置，能够拿出当前发丝顶点是否在待碰撞体内还是体外的信息（由上节我们知道，内部为负，外部为正，绝对值越大，距离碰撞体边界越远），如果当前的发丝顶点在待碰撞体内，那么这个顶点就是需要纠正的顶点，然后我们根据这个顶点附近周围的晶胞值，计算出一个梯度方向，这个梯度方向就是将这个顶点移出待碰撞体内所需要移动的位移最小的方向（由于此时是反算，梯度计算出来的结果，得出的是一个局部最优解，会受“附近”这一范围选取的影响），而顶点所在位置的晶胞值的绝对值，即是移动到待碰撞体边界的位移量。</p><p>我们看个TressFX提供的简单的例子：</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/TressFX_Doc_10.jpg" alt="有向距离场"></p><p>上图中的有向距离场是我们在前一个Pass中建好的，图中的2D网格是在这个有向距离场中选取的其中一面的晶胞，假设网格中的三角形就是待碰撞的物体的triangle，那么我们能看到：当一个晶胞的中心在三角形内部时，晶胞值是负数；当一个晶胞的中心在三角形外时，晶胞值是正数（empty时是默认的INITIAL_DISTANCE，是最大值1e10f）。由于当晶胞是一个较小的正数时，仅表征了晶胞的中心在三角形外，但是待碰撞体的三角形有可能仍然占据了晶胞的部分（最多可能占据了二分之一），因此TressFX提供了一个裕量（即代码中的g_CollisionMargin）给技美设置，在矫正时发丝顶点的位移量会多加上这一个裕量，使得发丝尽可能保证矫正到碰撞体之外。</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/TressFX_Doc_11.jpg" alt="碰撞矫正算法"></p><p>矫正过程如上图，这是当前Pass要做的事情。逐发丝顶点比较顶点所在位置的晶胞值，如果是一个小于裕量的值（晶胞值为负数、或为比裕量小的小值正数），就会计算出当前的顶点位置的晶胞值梯度方向作为矫正方向，矫正的位移量为裕量减去晶胞值（若晶胞值为负数，得到结果即晶胞值绝对值加上裕量，即SDF中记录当前晶胞中心到待碰撞体边界的最近的距离加上裕量；若晶胞值为正数，说明当前晶胞位置处在边界附近，计算出的结果只为裕量内的调整量）。</p><p>通过研究它的矫正算法，结合我在实际落地时的场景，我们能发现这个矫正算法是有一定的固有缺陷的。</p><p>首先是，我们的碰撞矫正是基于发丝的顶点做的，那么就有一种特殊的情况，待碰撞体有一个尖锐的突角，使得待碰撞体的Mesh网格中有三角形的一个点距离另外的两个点比较远，如下图所示，这种情况下发丝上的顶点所在位置的晶胞值都为正数，不会做矫正，但是发丝线却穿过了待碰撞体，产生了穿模。我们可以通过增多一根发丝上的顶点个数来缓解这一问题，但顶点数增多会导致计算量变大。</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/20220627231603.jpg" alt="corner case 1"></p><p>其次是，类似耳朵部位处的地方，当出现凹包时，即使将顶点矫正到了待碰撞体的外部（但在凹包范围内），仍有可能由于前面的缺陷，造成穿模的现象，如下图所示。我们可以通过生成tfxmesh时使用一个凸包代理模型来规避这个问题。</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/20220627231614.jpg" alt="corner case 2"></p><p>最后是，由于在生成SDF时我们采用的是遍历逐三角形去写三角形临近晶胞的方法，这样会导致待碰撞体网格内部离边界较远一点的地方仍是初始值。如下图所示，当碰撞体为内部黑色的球，建的SDF晶胞盒子是大的立方体，那图中红色虚拟球内的区域在碰撞球内远离球的边界，这部分范围内的晶胞值仍然会是初始的1e10f值。这就会导致当有发丝顶点进入了待碰撞体的内部时，矫正算法就失效了，不会移动这些发丝顶点到体外。我们可以通过确保生成tfxmesh的模型是一个完整封闭的模型且发丝顶点的初始位置一定不在碰撞体模型内来规避这个问题。</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/20220627231623.jpg" alt="corner case 3"></p><p>碰撞矫正会对所有的发丝顶点执行计算，包括引导发丝和从属发丝，最后来看一下代码，实现其实不难理解。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">//SDF-Hair collision using forward differences only</span><br><span class="line">// One thread per one hair vertex</span><br><span class="line">[numthreads(THREAD_GROUP_SIZE, 1, 1)]</span><br><span class="line">void CollideHairVerticesWithSdf_forward(uint GIndex : SV_GroupIndex,</span><br><span class="line">    uint3 GId : SV_GroupID, uint3 DTid : SV_DispatchThreadID)</span><br><span class="line">&#123;</span><br><span class="line">    int hairVertexGlobalIndex = GId.x * THREAD_GROUP_SIZE + GIndex;</span><br><span class="line"></span><br><span class="line">    if(hairVertexGlobalIndex &gt;= g_NumTotalHairVertices)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    int hairVertexLocalIndex = hairVertexGlobalIndex % g_NumHairVerticesPerStrand;</span><br><span class="line"></span><br><span class="line">    // We don&#x27;t run collision check on the first two vertices in the strand. They are fixed on the skin mesh.</span><br><span class="line">    if (hairVertexLocalIndex == 0 || hairVertexLocalIndex == 1)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    float4 hairVertex = g_HairVertices[hairVertexGlobalIndex];</span><br><span class="line">    float4 vertexInSdfLocalSpace = hairVertex;</span><br><span class="line"></span><br><span class="line">    // GetSignedDistance获取晶胞值的插值结果，数学计算过程，略，详见：</span><br><span class="line">    // https://github.com/GPUOpen-Effects/TressFX/blob/v4.1.0/src/Shaders/TressFXSDFCollision.hlsl#L414-L527</span><br><span class="line">    float distance = GetSignedDistance(vertexInSdfLocalSpace.xyz);</span><br><span class="line"></span><br><span class="line">    // early exit if the distance is larger than collision margin</span><br><span class="line">    if(distance &gt; g_CollisionMargin) // 前面算法描述中提及，当distance&lt;g_CollisionMargin时，发丝在待碰撞体边界加上一个裕量的范围之外</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    // small displacement. </span><br><span class="line">    float h = 0.1f * g_CellSize; // 用来计算梯度方向时的“附近”的量化范围</span><br><span class="line"></span><br><span class="line">    float3 sdfGradient;</span><br><span class="line">    &#123;</span><br><span class="line">        //Compute gradient using forward difference</span><br><span class="line">        float3 offset[3];</span><br><span class="line">        offset[0] = float3(1, 0, 0);</span><br><span class="line">        offset[1] = float3(0, 1, 0);</span><br><span class="line">        offset[2] = float3(0, 0, 1);</span><br><span class="line"></span><br><span class="line">        float3 neighborCellPositions[3];</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; 3; ++i) </span><br><span class="line">            neighborCellPositions[i] = vertexInSdfLocalSpace.xyz + offset[i] * h;</span><br><span class="line"></span><br><span class="line">        //Use trilinear interpolation to get distances</span><br><span class="line">        float neighborCellDistances[3];</span><br><span class="line"></span><br><span class="line">        for(int j = 0; j &lt; 3; ++j) </span><br><span class="line">            neighborCellDistances[j] = GetSignedDistance(neighborCellPositions[j]);</span><br><span class="line"></span><br><span class="line">        float3 forwardDistances;</span><br><span class="line">        forwardDistances.x = neighborCellDistances[0];</span><br><span class="line">        forwardDistances.y = neighborCellDistances[1];</span><br><span class="line">        forwardDistances.z = neighborCellDistances[2];</span><br><span class="line"></span><br><span class="line">        sdfGradient = ( forwardDistances - float3(distance, distance, distance) ) / h; // 梯度方向</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //Project hair vertex out of SDF</span><br><span class="line">    float3 normal = normalize(sdfGradient);</span><br><span class="line">    </span><br><span class="line">    if(distance &lt; g_CollisionMargin)</span><br><span class="line">    &#123;</span><br><span class="line">        // normal * (g_CollisionMargin - distance) 算出在梯度方向上的矫正量，</span><br><span class="line">        // 当发丝顶点完全在碰撞体内时，distance为负数；当发丝顶点在碰撞体边界附近的裕量范围内时，distance为正数。</span><br><span class="line">        // (g_CollisionMargin-distance)得到的是矫正到碰撞体外再加上一个裕量的位置的位移量。</span><br><span class="line">        float3 projectedVertex = hairVertex.xyz + normal * (g_CollisionMargin - distance);</span><br><span class="line">        g_HairVertices[hairVertexGlobalIndex].xyz = projectedVertex;</span><br><span class="line">        g_PrevHairVertices[hairVertexGlobalIndex].xyz = projectedVertex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Faster SDF-Hair collision mixing forward and backward differences</span><br><span class="line">// One thread per one hair vertex</span><br><span class="line">[numthreads(THREAD_GROUP_SIZE, 1, 1)]</span><br><span class="line">void CollideHairVerticesWithSdf(uint GIndex : SV_GroupIndex,</span><br><span class="line">    uint3 GId : SV_GroupID, uint3 DTid : SV_DispatchThreadID)</span><br><span class="line">&#123;</span><br><span class="line">    //When using forward differences to compute the SDF gradient,</span><br><span class="line">    //we need to use trilinear interpolation to look up 4 points in the SDF.</span><br><span class="line">    //In the worst case, this involves reading the distances in 4 different cubes (reading 32 floats from the SDF).</span><br><span class="line">    //In the ideal case, only 1 cube needs to be read (reading 8 floats from the SDF).</span><br><span class="line">    //The number of distance lookups varies depending on whether the 4 points cross cell boundaries.</span><br><span class="line">    //</span><br><span class="line">    //If we assume that (h &lt; g_CellSize), where h is the distance between the points used for finite difference,</span><br><span class="line">    //we can mix forwards and backwards differences to ensure that the points never cross cell boundaries (always read 8 floats).</span><br><span class="line">    //By default we use forward differences, and switch to backwards differences for each dimension that crosses a cell boundary.</span><br><span class="line">    //</span><br><span class="line">    //This is much faster than using forward differences only, but it could also be less stable.</span><br><span class="line">    //In particular, it has the effect of making the gradient less accurate. The amount of inaccuracy is </span><br><span class="line">    //proportional to the size of h, so it is recommended keep h as low as possible.</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    TressFX提供了另一套矫正算法，思路稍有改变，主要区别在计算梯度方向和矫正量上，略，感兴趣可以参考：</span><br><span class="line">    https://github.com/GPUOpen-Effects/TressFX/blob/v4.1.0/src/Shaders/TressFXSDFCollision.hlsl#L597-L715</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>毛发的物理部分到这里就结束啦，到此时，我们已经准备好了可以供后续渲染处理的发丝数据（还不是三角形网格数据，只是发丝曲线上的关键点），后续的文章将进入渲染部分。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;毛发发丝的碰撞矫正&quot;&gt;&lt;a href=&quot;#毛发发丝的碰撞矫正&quot; class=&quot;headerlink&quot; title=&quot;毛发发丝的碰撞矫正&quot;&gt;&lt;/a&gt;毛发发丝的碰撞矫正&lt;/h1&gt;&lt;p&gt;本文仅在个人博客及个人知乎上采用”CC BY-NC-ND 4.0”(署名-不可商用-</summary>
      
    
    
    
    <category term="开发杂记" scheme="https://blog.kdyx.net/categories/%E5%BC%80%E5%8F%91%E6%9D%82%E8%AE%B0/"/>
    
    <category term="CV/CG" scheme="https://blog.kdyx.net/categories/%E5%BC%80%E5%8F%91%E6%9D%82%E8%AE%B0/CV-CG/"/>
    
    
    <category term="Hair" scheme="https://blog.kdyx.net/tags/Hair/"/>
    
    <category term="毛发渲染" scheme="https://blog.kdyx.net/tags/%E6%AF%9B%E5%8F%91%E6%B8%B2%E6%9F%93/"/>
    
    <category term="物理模拟" scheme="https://blog.kdyx.net/tags/%E7%89%A9%E7%90%86%E6%A8%A1%E6%8B%9F/"/>
    
    <category term="数字人" scheme="https://blog.kdyx.net/tags/%E6%95%B0%E5%AD%97%E4%BA%BA/"/>
    
    <category term="发丝" scheme="https://blog.kdyx.net/tags/%E5%8F%91%E4%B8%9D/"/>
    
    <category term="TressFX" scheme="https://blog.kdyx.net/tags/TressFX/"/>
    
  </entry>
  
  <entry>
    <title>保姆级毛发算法调研分析，十万长文带你深入TressFX（二）</title>
    <link href="https://blog.kdyx.net/blog/kongdeyou/hair_simulation_and_rendering_2/"/>
    <id>https://blog.kdyx.net/blog/kongdeyou/hair_simulation_and_rendering_2/</id>
    <published>2022-06-03T15:18:22.000Z</published>
    <updated>2024-04-04T03:53:39.524Z</updated>
    
    <content type="html"><![CDATA[<h1 id="毛发物理模拟算法分析"><a href="#毛发物理模拟算法分析" class="headerlink" title="毛发物理模拟算法分析"></a>毛发物理模拟算法分析</h1><p>本文仅在个人博客及个人知乎上采用”CC BY-NC-ND 4.0”(署名-不可商用-禁止演绎)协议发布，转载请注明个人博客的原文链接及作者信息，侵权必究。</p><p>博客链接：<a href="https://tis.ac.cn/blog/kongdeyou/hair_simulation_and_rendering_2/">https://tis.ac.cn/blog/kongdeyou/hair_simulation_and_rendering_2/</a></p><p>知乎链接：<a href="https://zhuanlan.zhihu.com/p/527086980/">https://zhuanlan.zhihu.com/p/527086980/</a></p><p>本文将主要分析TressFX毛发系统中物理模拟的动力学计算和风场计算，目录结构如下：</p><p>[toc]</p><h2 id="发丝建模"><a href="#发丝建模" class="headerlink" title="发丝建模"></a>发丝建模</h2><p><strong>建模</strong>：TressFX将每一根头发(hair)等效为一根发丝(strand)，一根发丝由一系列连续的发丝线段(segment)组成，每段的端点作为一个质点。</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/TressFX_Doc_01.png" alt="头发物理建模"></p><p>通过模拟这些质点的运动，再连接这些质点，近似实现头发的物理运动模拟。为了减少头发的物理计算量，将发丝分为引导发丝(guide strand)和从属发丝(follow strand)，发丝的动力学模拟和风场模拟仅采用引导发丝来计算，由引导发丝通过偏移产生从属发丝的结果，而碰撞检测与矫正将对所有发丝都进行处理。</p><p><strong>约束</strong>：TressFX针对头发的物理真实现象，对发丝的物理运动进行了如下约束，用以进行发丝的物理计算：</p><ol><li>发丝根部的两个质点与角色(actor)或头发附着体(hair-attached object)保持相对固定，后续质点受重力的作用(gravitational force)而自由落体；</li><li>发丝本身有一定的弯曲形状(global shape constraints)需要保持；</li><li>发丝在跟随角色或附着体运动时需要实现相应的质点运动策略(velocity shock propagation)，即牵连加速度对头发位置会产生影响；</li><li>发丝中每个质点的位置都会受前后质点的影响(local shape constraints)，遵循弹簧质点模型；</li><li>发丝在风场中会受风力(wind influence)的影响；</li><li>发丝每一段的长度(length constriants)需要保持不变；</li><li>发丝碰撞检测系统基于有符号距离场(SDF)。</li></ol><h2 id="动力学计算"><a href="#动力学计算" class="headerlink" title="动力学计算"></a>动力学计算</h2><p>头发的物理模拟过程完全使用compute shader进行计算，开始前先简单复习一下一会儿会使用的计算管线的一些概念。</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/TressFX_Others_ThreadGroupIds.png" alt="一图看懂计算管线系统参数"></p><p>在TressFX中，仅会使用<code>Dispatch(N, 1, 1)</code>和<code>[numthreads(THREAD_GROUP_SIZE, 1, 1)]</code>，其中THREAD_GROUP_SIZE为固定值64（既符合NVIDIA显卡基于SIMD32要求的必须是32的倍数，又满足AMD显卡基于wavefront要求的必须是64的倍数）。</p><p>即TressFX使用的配置为：每Dispatch一次，有<code>(N*1*1)</code>个线程组，每个线程组内有<code>(THREAD_GROUP_SIZE*1*1)</code>个线程。</p><p>Shader代码中，仅使用<code>SV_GroupIndex</code>、<code>SV_GroupID</code>和<code>SV_DispatchThreadID</code>，类似如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[numthreads(THREAD_GROUP_SIZE, 1, 1)]</span><br><span class="line">void IntegrationAndGlobalShapeConstraints(</span><br><span class="line">    uint GIndex : SV_GroupIndex,</span><br><span class="line">    uint3 GId : SV_GroupID,</span><br><span class="line">    uint3 DTid : SV_DispatchThreadID)</span><br><span class="line">&#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>SV_GroupIndex：当前线程在线程组内的唯一索引值。</li><li>SV_GroupThreadID：当前线程在线程组内的唯一ID，由于始终使用<code>[numthreads(THREAD_GROUP_SIZE, 1, 1)]</code>，因此只有x分量有效，yz分量值始终为0，而x分量的值又即为GIndex的值，因此在TressFX的shader代码中不传该值了。</li><li>SV_GroupID：当前线程所在的线程组在整个分发的线程组中的ID，由于始终使用<code>Dispatch(N, 1, 1)</code>，GId仅使用x分量，yz分量值始终为0。</li><li>SV_DispatchThreadID：当前线程在整个分发的所有线程组中的ID,在所有分发的线程中唯一，为<code>uint3(SV_GroupID * [numthreads] + SV_GroupThreadID)</code>，同样仅x分量有效，TressFX的shader代码中虽然入参有它但未使用过该值。</li></ul><h3 id="重力与全局形状约束"><a href="#重力与全局形状约束" class="headerlink" title="重力与全局形状约束"></a>重力与全局形状约束</h3><p>针对场景中的每个头发，均需要1个pass来计算头发的重力和全局形状约束。红色箭头线是当前pass的输入，绿色箭头线是当前pass的输出，后文的图片中相同的颜色箭头线所表示的意义是一样的。</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/TressFX_04.png" alt="重力与全局形状约束的Pass图"></p><p>将<em>头发发丝的初始顶点数据和发丝的骨骼数据（来自于.tfx文件，vertex position, bone indices and bone weight，每根发丝由多个顶点组成，而每根发丝上的顶点都共用一套bone indices and bone weight，因为只有发根会和头部模型固连，头部模型骨骼的影响作用于发根的顶点，进而传递到发丝上其他的顶点上）</em>、<em>上一帧处理输出的顶点数据结果</em>输入该pass，进行重力与全局形状约束的处理后，输出<em>当前帧的头发发丝的顶点位置</em>、更新<em>上上帧和上帧的头发发丝的顶点位置</em>。</p><p>在看具体的重力与全局形状约束算法之前，我们先看看传递给这个pass的constant buffer。下面的这个tressfxSimParameters会在重力与全局形状约束、速度震动传播、局部形状约束、长度约束和风场模拟、引导发丝生成从属发丝的pass中都会被使用（有且仅有这一个constant buffer）。这几个pass用到的参数各不相同，我将在使用到的时候具体介绍参数的意义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// constants that change frame to frame</span><br><span class="line">[[vk::binding(13, 0)]] cbuffer tressfxSimParameters : register(b13, space0)</span><br><span class="line">&#123;</span><br><span class="line">    float4 g_Wind;</span><br><span class="line">    float4 g_Wind1;</span><br><span class="line">    float4 g_Wind2;</span><br><span class="line">    float4 g_Wind3;</span><br><span class="line"></span><br><span class="line">    float4 g_Shape;       // damping, local stiffness, global stiffness, global range.</span><br><span class="line">    float4 g_GravTimeTip; // gravity maginitude (assumed to be in negative y direction.)</span><br><span class="line">    int4   g_SimInts;     // length iterations, local iterations, collision flag.</span><br><span class="line">    int4   g_Counts;      // num strands per thread group, num follow hairs per guid hair, num verts per strand.</span><br><span class="line">    float4 g_VSP;         // VSP parmeters</span><br><span class="line"></span><br><span class="line">    float g_ResetPositions;</span><br><span class="line">    float g_ClampPositionDelta;</span><br><span class="line">    float g_pad1;</span><br><span class="line">    float g_pad2;</span><br><span class="line"></span><br><span class="line">    row_major float4x4 g_BoneSkinningMatrix[AMD_TRESSFX_MAX_NUM_BONES]; // #define AMD_TRESSFX_MAX_NUM_BONES 512</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define g_NumOfStrandsPerThreadGroup      g_Counts.x</span><br><span class="line">#define g_NumFollowHairsPerGuideHair      g_Counts.y</span><br><span class="line">#define g_NumVerticesPerStrand            g_Counts.z // Shader中从未使用的变量，因为THREAD_GROUP_SIZE的值固定，且有g_NumOfStrandsPerThreadGroup，</span><br><span class="line">                                                     // 用(THREAD_GROUP_SIZE / g_NumOfStrandsPerThreadGroup)就能计算出每根发丝上的顶点数</span><br><span class="line"></span><br><span class="line">#define g_NumLocalShapeMatchingIterations g_SimInts.y</span><br><span class="line"></span><br><span class="line">#define g_GravityMagnitude                g_GravTimeTip.x</span><br><span class="line">#define g_TimeStep                        g_GravTimeTip.y</span><br><span class="line">#define g_TipSeparationFactor             g_GravTimeTip.z</span><br></pre></td></tr></table></figure><p>在C++中对应的结构体为TressFXSimulationParams：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TressFXSimulationParams</span></span><br><span class="line">&#123;</span><br><span class="line">    AMD::float4 m_Wind;</span><br><span class="line">    AMD::float4 m_Wind1;</span><br><span class="line">    AMD::float4 m_Wind2;</span><br><span class="line">    AMD::float4 m_Wind3;</span><br><span class="line"></span><br><span class="line">    AMD::float4 m_Shape;</span><br><span class="line">    <span class="comment">// float m_Damping;                           // damping</span></span><br><span class="line">    <span class="comment">// float m_StiffnessForLocalShapeMatching;    // local stiffness</span></span><br><span class="line">    <span class="comment">// float m_StiffnessForGlobalShapeMatching;   // global stiffness</span></span><br><span class="line">    <span class="comment">// float m_GlobalShapeMatchingEffectiveRange; // global range</span></span><br><span class="line"></span><br><span class="line">    AMD::float4 m_GravTimeTip;</span><br><span class="line">    <span class="comment">// float m_GravityMagnitude; // gravity</span></span><br><span class="line">    <span class="comment">// float m_TimeStep;         // time step size</span></span><br><span class="line">    <span class="comment">// float m_TipSeparationFactor;</span></span><br><span class="line">    <span class="comment">// float m_velocityShockPropogation;</span></span><br><span class="line"></span><br><span class="line">    AMD::sint4 m_SimInts; <span class="comment">// 4th component unused.</span></span><br><span class="line">    <span class="comment">// int m_NumLengthConstraintIterations;</span></span><br><span class="line">    <span class="comment">// int m_NumLocalShapeMatchingIterations;</span></span><br><span class="line">    <span class="comment">// int m_bCollision;</span></span><br><span class="line">    <span class="comment">// int m_CPULocalIterations;</span></span><br><span class="line"></span><br><span class="line">    AMD::sint4 m_Counts; <span class="comment">// 4th component unused.</span></span><br><span class="line">    <span class="comment">// int m_NumOfStrandsPerThreadGroup;</span></span><br><span class="line">    <span class="comment">// int m_NumFollowHairsPerGuideHair;</span></span><br><span class="line">    <span class="comment">// int m_NumVerticesPerStrand; // should be 2^n (n is integer and greater than 2) and less than</span></span><br><span class="line">                                   <span class="comment">// or equal to TRESSFX_SIM_THREAD_GROUP_SIZE. i.e. 8, 16, 32 or 64</span></span><br><span class="line"></span><br><span class="line">    AMD::float4 m_VSP;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> g_ResetPositions;</span><br><span class="line">    <span class="type">float</span> g_ClampPositionDelta;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> g_pad1;</span><br><span class="line">    <span class="type">float</span> g_pad2;</span><br><span class="line"></span><br><span class="line">    AMD::float4x4 m_BoneSkinningMatrix[AMD_TRESSFX_MAX_NUM_BONES]; <span class="comment">// #define AMD_TRESSFX_MAX_NUM_BONES 512</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再来看一下这几个buffer，它们将跟随我们后面几乎所有的passes（可以对照RenderPass总览图），TressFX将用它们存储所有的发丝顶点数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// UAVs</span><br><span class="line">[[vk::binding(0, 1)]] RWStructuredBuffer&lt;float4&gt; g_HairVertexPositions         : register(u0, space1);  // 对应RenderPass图中的资源&lt;08&gt;</span><br><span class="line">[[vk::binding(1, 1)]] RWStructuredBuffer&lt;float4&gt; g_HairVertexPositionsPrev     : register(u1, space1);  // 对应RenderPass图中的资源&lt;09&gt;</span><br><span class="line">[[vk::binding(2, 1)]] RWStructuredBuffer&lt;float4&gt; g_HairVertexPositionsPrevPrev : register(u2, space1);  // 对应RenderPass图中的资源&lt;10&gt;</span><br><span class="line">[[vk::binding(3, 1)]] RWStructuredBuffer&lt;float4&gt; g_HairVertexTangents          : register(u3, space1);  // 对应RenderPass图中的资源&lt;13&gt;</span><br><span class="line">// SRVs</span><br><span class="line">[[vk::binding(4, 0)]] StructuredBuffer&lt;float4&gt; g_InitialHairPositions          : register(t4, space0);  // 对应RenderPass图中的资源&lt;06&gt;</span><br><span class="line">[[vk::binding(12, 0)]] StructuredBuffer&lt;BoneSkinningData&gt; g_BoneSkinningData   : register(t12, space0); // 对应RenderPass图中的资源&lt;07&gt;</span><br></pre></td></tr></table></figure><p>下面开始正式进入这一节的正题，TressFX的重力计算使用带阻尼的Verlet自由落体运动公式：</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/TressFX_Doc_02.png" alt="带阻尼的Verlet自由落体运动公式"></p><p>其中：DampingCoeff为阻尼系数（取值范围[0, 1]，默认值0.035），Gravity为重力加速度（方向锁定为-y轴，默认值9.8），TimeStep为时间步长（即一帧的时间间隔，单位为秒，60帧时步长约是0.01666667），在公式中是积分微元；NewPos对应的是当前计算帧的位置，CurPos是上一帧的位置，OldPos是上上帧的位置。</p><p>根据实际物理现象，TressFX限制发丝根部的两个质点与附着体保持相对固定，即发丝根部的两个质点不计算重力。</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/TressFX_Doc_03.png" alt="发丝根部的两个质点"></p><p>TressFX的全局形状约束约束的是发丝根部之后的若干个质点，由于头发有一定的刚度，它们需要保持一个基本的弯曲形状，形成类似定型的效果。</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/TressFX_Doc_04.png" alt="全局形状约束与范围"></p><p>该约束在量化实现上为：在计算重力给质点带来的影响后，补偿性地加上一个抵抗变化的位置改变。</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/TressFX_Formula_03.jpg" alt="全局形状约束公式"></p><p>其中，GlobalConstraintStiffiness是全局形状约束的刚度值（取值范围[0, 1]，默认值0.01），这个值越大，刚度越高，抵抗变化的补偿值就越大，于是表现上就是发丝越不容易弯曲，越靠近InitialPos；InitialPos是发丝建模时的初始位置，CurrentPos是经过前面的重力计算后得出的位置，NewPos是经过全局形状约束后的输出位置。</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/TressFX_Doc_05.png" alt="InitialPos和CurrentPos"></p><p>由于全局形状约束仅作用于发丝根部之后的若干个质点，TressFX引入一个系数GlobalConstraintRange来量化“若干”的范围（该系数取值[0, 1]，默认值0.3），用来表示需要全局形状约束的质点个数的占比，对应于“全局形状约束与范围”图(上上图)中的红色方框部分的质点。</p><p>综上，重力与全局形状约束的pass将使用以下的参数：</p><ul><li>float4 g_Shape<br>g_Shape.x: DampingCoeff<br>g_Shape.z: GlobalConstraintStiffness<br>g_Shape.w: GlobalConstraintRange</li><li>float4 g_GravTimeTip<br>g_GravTimeTip.x -&gt; g_GravityMagnitude: Gravity<br>g_GravTimeTip.y -&gt; g_TimeStep: TimeStep</li><li>int4 g_Counts<br>g_Counts.x -&gt; g_NumOfStrandsPerThreadGroup: num strands per thread group<br>g_Counts.y -&gt; g_NumFollowHairsPerGuideHair: num follow hairs per guid hair</li><li>float g_ResetPositions：如果非0.0f将会重置currentPos和oldPos为initialPos<br>（TressFX用的float，使用int或许好看些，盲猜TressFX原先想的是重置为该值，后来重置为initialPos后，没改掉这个值的类型）</li><li>float4x4 g_BoneSkinningMatrix数组：骨骼反向绑定矩阵</li></ul><p>重力与全局形状约束的着色器入口点是IntegrationAndGlobalShapeConstraints，它针对发丝的质点（顶点）并行计算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//--------------------------------------------------------------------------------------</span><br><span class="line">//</span><br><span class="line">//  IntegrationAndGlobalShapeConstraints</span><br><span class="line">//</span><br><span class="line">//  Compute shader to simulate the gravitational force with integration and to maintain the</span><br><span class="line">//  global shape constraints.</span><br><span class="line">//</span><br><span class="line">// One thread computes one vertex.</span><br><span class="line">//</span><br><span class="line">//--------------------------------------------------------------------------------------</span><br><span class="line">[numthreads(THREAD_GROUP_SIZE, 1, 1)]</span><br><span class="line">void IntegrationAndGlobalShapeConstraints(uint GIndex : SV_GroupIndex,</span><br><span class="line">    uint3 GId : SV_GroupID, uint3 DTid : SV_DispatchThreadID)</span><br><span class="line">&#123;</span><br><span class="line">    uint globalStrandIndex, localStrandIndex, globalVertexIndex, localVertexIndex; // 作为CalcIndicesInVertexLevelMaster的输出</span><br><span class="line">    uint numVerticesInTheStrand, indexForSharedMem, strandType;                    // 作为CalcIndicesInVertexLevelMaster的输出</span><br><span class="line">    CalcIndicesInVertexLevelMaster(GIndex, GId.x,</span><br><span class="line">        globalStrandIndex, localStrandIndex,</span><br><span class="line">        globalVertexIndex, localVertexIndex,</span><br><span class="line">        numVerticesInTheStrand, indexForSharedMem, strandType);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码中的CalcIndicesInVertexLevelMaster函数计算每一根发丝（仅针对guide hair，之后的物理计算pass直到UpdateFollowHairVertices前，都是仅针对guide hair做计算，UpdateFollowHairVertices会根据guide hair通过偏移来生成follow hair）的每一个顶点的索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">void CalcIndicesInVertexLevelMaster(</span><br><span class="line">    uint local_id, // 当前线程在线程组内的索引</span><br><span class="line">    uint group_id, // 当前线程所在的线程组在整个分发的线程组中的索引</span><br><span class="line">    inout uint globalStrandIndex, inout uint localStrandIndex,</span><br><span class="line">    inout uint globalVertexIndex, inout uint localVertexIndex,</span><br><span class="line">    inout uint numVerticesInTheStrand, inout uint indexForSharedMem, inout uint strandType)</span><br><span class="line">&#123;</span><br><span class="line">    // indexForSharedMem意义：以[当前线程在线程组内的索引值]作为[线程组内共享内存的索引]</span><br><span class="line">    // 该索引所指向的共享内存的位置为当前线程所持有的内存，即当前的发丝顶点所持有的内存</span><br><span class="line">    indexForSharedMem = local_id;</span><br><span class="line"></span><br><span class="line">    // numVerticesInTheStrand意义：一根发丝的顶点数</span><br><span class="line">    // 由于限制了THREAD_GROUP_SIZE为64，所以一根发丝最多只能有64个顶点</span><br><span class="line">    // 为了线程个数凑整对齐，一根发丝上的顶点数限制取值为2的幂次方，即有效值为2、4、8、16、32、64</span><br><span class="line">    numVerticesInTheStrand = (THREAD_GROUP_SIZE / g_NumOfStrandsPerThreadGroup); // g_NumOfStrandsPerThreadGroup即g_Counts.x，参见上文本pass使用的参数</span><br><span class="line"></span><br><span class="line">    // localStrandIndex意义：当前顶点所属的局部发丝索引，局部范围为线程组内</span><br><span class="line">    // 假设：一根发丝有16个顶点，那么传下来的g_NumOfStrandsPerThreadGroup即为4，前一行代码算出一根发丝上的顶点数：numVerticesInTheStrand=64/4=16</span><br><span class="line">    // 那么：当前线程组内的每一个线程（代表一个顶点）所属的局部头发索引值为localStrandIndex</span><br><span class="line">    //                   +---------------------------------------------------------+</span><br><span class="line">    // localStrandIndex: |00|01|02|03|00|01|02|03|00|01|02|03|00|01|02|03|...|02|03|</span><br><span class="line">    //                   |---------------------------------------------------------|</span><br><span class="line">    // local_id:         |00|01|02|03|04|05|06|07|08|09|10|11|12|13|14|15|...|62|63|</span><br><span class="line">    //                   +---------------------------------------------------------+</span><br><span class="line">    // 一根头发上的16个顶点不是连续的线程在处理，该线程组内的第一根头发上的顶点分别由第00号、04号、08号、12号、……、60号线程在处理</span><br><span class="line">    localStrandIndex = local_id % g_NumOfStrandsPerThreadGroup;</span><br><span class="line"></span><br><span class="line">    // globalStrandIndex意义：发丝全局唯一索引 = (线程组索引 * 每个线程组的发丝数量 + 当前发丝在线程组内的局部索引) * 跳过从属发丝</span><br><span class="line">    globalStrandIndex = group_id * g_NumOfStrandsPerThreadGroup + localStrandIndex;</span><br><span class="line">    globalStrandIndex *= (g_NumFollowHairsPerGuideHair+1);</span><br><span class="line"></span><br><span class="line">    // localVertexIndex意义：局部顶点索引，按上表（localStrandIndex与local_id对照表）可推出</span><br><span class="line">    localVertexIndex = (local_id - localStrandIndex) / g_NumOfStrandsPerThreadGroup;</span><br><span class="line"></span><br><span class="line">    // globalVertexIndex意义：全局顶点索引，类似globalStrandIndex可推出</span><br><span class="line">    globalVertexIndex = globalStrandIndex * numVerticesInTheStrand + localVertexIndex;</span><br><span class="line"></span><br><span class="line">    // GetStrandType始终返回0，目前没有使用strandType</span><br><span class="line">    // 盲猜TressFX原先想在每根头发上加上头发类型，根据类型可以选择不同的头发参数进行计算，但是目前tressfxSimParameters只会传一份头发参数进来</span><br><span class="line">    // 这个功能估计是想实现出一个hair object可以有多种配置参数，实现出刘海部分和头发主体部分分别使用不同的参数，当然这样也会带来新的问题，</span><br><span class="line">    // 比如Editor上不好设计出简洁的UI给技美调参，增大使用难度，又如在Editor上选定了一个hair object后（一般作为某个entity的一个component），</span><br><span class="line">    // 需要针对不同的配置参数影响到的发丝给出一个可视化的呈现，这才能让技美感知到它正在调整的参数对应的发丝是哪些。另外，如果要给定StrandType</span><br><span class="line">    // 还需要美术在制作发丝模型时还需要另外给出发丝的类型，TressFX还要实现出相应的工具链上的解决方案。</span><br><span class="line">    strandType = GetStrandType(globalStrandIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在CalcIndicesInVertexLevelMaster中出参有一个indexForSharedMem，用它来访问的共享内存如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 线程组内共享变量，整个线程组内的所有线程共享</span><br><span class="line">groupshared float4 sharedPos[THREAD_GROUP_SIZE];</span><br><span class="line">groupshared float4 sharedTangent[THREAD_GROUP_SIZE];</span><br><span class="line">groupshared float  sharedLength[THREAD_GROUP_SIZE];</span><br></pre></td></tr></table></figure><p>接下来进入正题，开始重力的积分计算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&#123;   // IntegrationAndGlobalShapeConstraints</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    float4 initialPos = g_InitialHairPositions[globalVertexIndex];</span><br><span class="line">    // Apply bone skinning to initial position</span><br><span class="line">    float4 bone_quat;</span><br><span class="line">    BoneSkinningData skinningData = g_BoneSkinningData[globalStrandIndex]; // g_BoneSkinningData数据存储了所有发丝的骨骼蒙皮数据</span><br><span class="line">    initialPos.xyz = ApplyVertexBoneSkinning(initialPos.xyz, skinningData, bone_quat);</span><br><span class="line">    // g_BoneSkinningData是对应于每一根发丝的，包括guide hair和follow hair</span><br><span class="line">    // 由于我们的follow hair实际上不需要这些骨骼相关的数据，它们是在UpdateFollowHairVertices中直接偏移生成的，因此follow hair位置上的BoneSkinningData全为0（可见下方图）</span><br><span class="line">    // 事实上，这里可以只把guide hair使用的骨骼相关的数据传下来，而不需要传follow hair的，这样可以节省一些带宽，然后用globalStrandIndex/(g_NumFollowHairsPerGuideHair+1)替换globalStrandIndex来得到索引</span><br><span class="line">    // ApplyVertexBoneSkinning函数，骨骼蒙皮相关的内容，略，详见：https://github.com/GPUOpen-Effects/TressFX/blob/v4.1.0/src/Shaders/TressFXSimulation.hlsl#L549-L571</span><br><span class="line">    // === 到此，我们准备好了：InitialPos ===</span><br><span class="line"></span><br><span class="line">    // position when this step starts. In other words, a position from the last step.</span><br><span class="line">    float4 currentPos = sharedPos[indexForSharedMem] = g_HairVertexPositions[globalVertexIndex]; // currentPos来自于前一帧的数据</span><br><span class="line">    // === 到此，我们准备好了：InitialPos、CurrentPos ===</span><br><span class="line"></span><br><span class="line">    GroupMemoryBarrierWithGroupSync(); // 由于我们对sharedPos共享区内的变量有写入操作，这里同步等待整个线程组内的线程都走到该语句后，才继续往下执行</span><br><span class="line"></span><br><span class="line">    float4 oldPos;</span><br><span class="line">    oldPos = g_HairVertexPositionsPrev[globalVertexIndex]; // oldPos来自于前一帧中保存的再前一帧的数据</span><br><span class="line">    // === 到此，我们准备好了：InitialPos、CurrentPos、OldPos ===</span><br><span class="line"></span><br><span class="line">    // 获取阻尼系数，StrandType尚未使用，GetDamping始终返回g_Shape.x</span><br><span class="line">    float dampingCoeff = GetDamping(strandType);</span><br><span class="line"></span><br><span class="line">    // reset if we got teleported</span><br><span class="line">    if (g_ResetPositions != 0.0f)</span><br><span class="line">    &#123;</span><br><span class="line">        currentPos = initialPos;</span><br><span class="line">        oldPos = initialPos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 发丝根部的两个质点不移动，currentPos的w分量为0.0或1.0，发丝根部的两个质点该分量为0.0</span><br><span class="line">    // 该值通过从g_InitialHairPositions给定的顶点的position.w给定，在C++上传递过来时就配置好了</span><br><span class="line">    // bool IsMovable(float4 particle)</span><br><span class="line">    // &#123;</span><br><span class="line">    //     if ( particle.w &gt; 0 )</span><br><span class="line">    //         return true;</span><br><span class="line">    //     return false;</span><br><span class="line">    // &#125;</span><br><span class="line">    // 这里TressFX的实现，其实不需要专门做个w分量去存它，我们前面已经在GPU侧算出来是否是发丝根部的两个质点了：</span><br><span class="line">    // if (localVertexIndex == 0 || localVertexIndex == 1) &#123; 发丝根部 &#125; else &#123; 非发丝根部 &#125;</span><br><span class="line">    // Integrate根据带阻尼的Verlet自由落体运动公式计算出新位置</span><br><span class="line">    if ( IsMovable(currentPos) )</span><br><span class="line">        sharedPos[indexForSharedMem].xyz = Integrate(currentPos.xyz, oldPos.xyz, initialPos.xyz, dampingCoeff);</span><br><span class="line">    else</span><br><span class="line">        sharedPos[indexForSharedMem] = initialPos;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/TressFX_Others_BoneSkinningData.jpg" alt="从RenderDoc抓帧数据中也能看出，follow hair不需要bone data数据"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 重力积分，即前面给出的：带阻尼的Verlet自由落体运动公式</span><br><span class="line">float3 Integrate(float3 curPosition, float3 oldPosition, float3 initialPos, float dampingCoeff = 1.0f)</span><br><span class="line">&#123;</span><br><span class="line">    float3 force = g_GravityMagnitude * float3(0, -1.0f, 0);</span><br><span class="line">    float decay = exp(-dampingCoeff * g_TimeStep * 60.0f);</span><br><span class="line">    return curPosition + decay * (curPosition - oldPosition) + force * g_TimeStep * g_TimeStep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是全局形状约束的实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;   // IntegrationAndGlobalShapeConstraints</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // Global Shape Constraints</span><br><span class="line">    float stiffnessForGlobalShapeMatching = GetGlobalStiffness(strandType); // 全局形状约束的刚度值，g_Shape.z</span><br><span class="line">    float globalShapeMatchingEffectiveRange = GetGlobalRange(strandType);   // 全局形状约束的影响范围，g_Shape.w</span><br><span class="line"></span><br><span class="line">    if ( stiffnessForGlobalShapeMatching &gt; 0 &amp;&amp; globalShapeMatchingEffectiveRange )</span><br><span class="line">    &#123;</span><br><span class="line">        // 这句可以用它替换：if (localVertexIndex != 0 &amp;&amp; localVertexIndex != 1)，这样就可以不使用position的w分量去存一个是否是发丝根的数据</span><br><span class="line">        if ( IsMovable(sharedPos[indexForSharedMem]) )</span><br><span class="line">        &#123;</span><br><span class="line">            // 判断localVertexIndex是否在影响范围(Range*numVerticesInTheStrand)内，即Range是个[0, 1]的比例值</span><br><span class="line">            if ( (float)localVertexIndex &lt; globalShapeMatchingEffectiveRange * (float)numVerticesInTheStrand )</span><br><span class="line">            &#123;</span><br><span class="line">                float factor = stiffnessForGlobalShapeMatching;</span><br><span class="line">                float3 del = factor * (initialPos - sharedPos[indexForSharedMem]).xyz;</span><br><span class="line">                sharedPos[indexForSharedMem].xyz += del; // 对应前面给出的全局形状约束补偿公式，CurrentPos位置加上一个到InitialPos的补偿值</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 更新顶点数据，包括上一帧和上上帧的数据</span><br><span class="line">    UpdateFinalVertexPositions(currentPos, sharedPos[indexForSharedMem], globalVertexIndex, localVertexIndex, numVerticesInTheStrand);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UpdateFinalVertexPositions(float4 oldPosition, float4 newPosition, int globalVertexIndex, int localVertexIndex, int numVerticesInTheStrand)</span><br><span class="line">&#123;</span><br><span class="line">    g_HairVertexPositionsPrevPrev[globalVertexIndex] = g_HairVertexPositionsPrev[globalVertexIndex];</span><br><span class="line">    g_HairVertexPositionsPrev[globalVertexIndex] = oldPosition;</span><br><span class="line">    g_HairVertexPositions[globalVertexIndex] = newPosition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，TressFX将数据刷到了g_HairVertexPositions、g_HairVertexPositionsPrev、g_HairVertexPositionsPrevPrev上，这些数据又会作为后续pass的输入数据。</p><h3 id="速度震动传播"><a href="#速度震动传播" class="headerlink" title="速度震动传播"></a>速度震动传播</h3><p>速度震动传播（直接翻译自TressFX的叫法：propagate velocity shock (VSP)）的主要描述是，当头发附着体有一个加速度的改变时，会有牵引加速度，因此会带来力的作用，头发即会因此而产生飘动。比如长头发的玩家角色突然往前加速跑动，头发会因此而被扬起，该玩家在抖头，头发也会因此而抖动。头发附着体的速度改变（震动）会从头皮传播到头发上。该过程针对每个头发模型需要2个pass来进行计算。</p><p>第一个pass用来计算头发附着体的变化量与瞬时加速度，由于发丝根部的两个顶点默认不可与角色相对移动，因此正好可用来计算整根发丝的整体变换，因而该pass仅需要针对每根guide hair发丝进行处理。</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/TressFX_05.png" alt="VSP的Pass图1"></p><p>第二个pass用来将效果作用到每根头发的每个顶点上。</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/TressFX_06.png" alt="VSP的Pass图2"></p><p>第一个pass将计算出的整体变换数据存储到g_StrandLevelData中，供第二个pass中使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct StrandLevelData</span><br><span class="line">&#123;</span><br><span class="line">    // Quat = Quaternion</span><br><span class="line">    float4 skinningQuat;   // 骨骼变换旋转量</span><br><span class="line">    float4 vspQuat;        // 头发附着体的旋转变化量</span><br><span class="line">    float4 vspTranslation; // 头发附着体的平移变化量，其中w分量用来存储加速度影响因子</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[[vk::binding(4, 1)]] RWStructuredBuffer&lt;StrandLevelData&gt; g_StrandLevelData : register(u4, space1);</span><br></pre></td></tr></table></figure><p>我们先来看第一个pass，shader的入口点是CalculateStrandLevelData。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//--------------------------------------------------------------------------------------</span><br><span class="line">//</span><br><span class="line">//  Calculate Strand Level Data</span><br><span class="line">//</span><br><span class="line">//  Propagate velocity shock resulted by attached based mesh</span><br><span class="line">//</span><br><span class="line">// One thread computes one strand.</span><br><span class="line">//</span><br><span class="line">//--------------------------------------------------------------------------------------</span><br><span class="line">[numthreads(THREAD_GROUP_SIZE, 1, 1)]</span><br><span class="line">void CalculateStrandLevelData(uint GIndex : SV_GroupIndex,</span><br><span class="line">    uint3 GId : SV_GroupID, uint3 DTid : SV_DispatchThreadID)</span><br><span class="line">&#123;</span><br><span class="line">    uint local_id, group_id, globalStrandIndex, numVerticesInTheStrand, globalRootVertexIndex, strandType;</span><br><span class="line">    CalcIndicesInStrandLevelMaster(GIndex, GId.x, globalStrandIndex, numVerticesInTheStrand, globalRootVertexIndex, strandType);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面提到，该pass仅需要针对每根guide hair发丝进行处理，因此此处调用的是CalcIndicesIn<strong>Strand</strong>LevelMaster（前一小节中，我们研究过了针对每根发丝上每个顶点计算索引的CalcIndicesIn<strong>Vertex</strong>LevelMaster函数）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void CalcIndicesInStrandLevelMaster(uint local_id, uint group_id,</span><br><span class="line">    inout uint globalStrandIndex, inout uint numVerticesInTheStrand, inout uint globalRootVertexIndex, inout uint strandType)</span><br><span class="line">&#123;</span><br><span class="line">    // 发丝全局唯一索引，同CalcIndicesInVertexLevelMaster中的计算方法</span><br><span class="line">    globalStrandIndex = THREAD_GROUP_SIZE * group_id + local_id;</span><br><span class="line">    globalStrandIndex *= (g_NumFollowHairsPerGuideHair+1);</span><br><span class="line"></span><br><span class="line">    // 每根发丝上的顶点数，同CalcIndicesInVertexLevelMaster中的计算方法</span><br><span class="line">    numVerticesInTheStrand = (THREAD_GROUP_SIZE / g_NumOfStrandsPerThreadGroup);</span><br><span class="line"></span><br><span class="line">    // 得到当前的发丝最根部处的顶点的全局唯一索引</span><br><span class="line">    // 注意，我们在CalcIndicesInVertexLevelMaster函数中曾提到过，一根发丝上的顶点的处理线程不是连续的（见上文CalcIndicesInVertexLevelMaster函数中的注释），</span><br><span class="line">    // 这里千万不要搞混了，只是处理线程（的索引）是不连续的，但是同一根发丝上的顶点数据在存储的GPU内存中是连续的！</span><br><span class="line">    // 那么g_HairVertexPositions[globalRootVertexIndex]是当前发丝根部的第一个顶点位置数据，</span><br><span class="line">    // 而g_HairVertexPositions[globalRootVertexIndex+1]是当前发丝根部的第二个顶点位置数据。</span><br><span class="line">    globalRootVertexIndex = globalStrandIndex * numVerticesInTheStrand;</span><br><span class="line"></span><br><span class="line">    // 未使用，始终返回0</span><br><span class="line">    strandType = GetStrandType(globalStrandIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来要计算出头发附着体的整体变换与瞬时加速度。</p><p>整体变换如下图所示，假设上一帧角色在t1时刻的位置，当前帧变换到了t2时刻的位置。针对图中所标示的发丝，发丝根部与角色头皮相连接处的两个顶点位置始终与角色保持相对固定，因此使发丝根部第一个顶点指向第二个顶点的方向构建向量，那么，t1时刻该向量为u，t2时刻该向量为v。</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/TressFX_Formula_01.jpg" alt="整体变换"></p><p>由此：发丝根部顶点的位移为平移变化量(vspTranslation)，向量u到向量v的改变量为旋转变化量(vspQuaternion)，旋转变化量可以用一个四元数来记录。</p><p>有了前两帧和当前帧的平移变化量，我们可以计算出一个瞬时加速度。</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/TressFX_Formula_02.jpg" alt="瞬时加速度公式"></p><p>TimeStep在重力计算时也出现过，帧间间隔的时间足够小，该公式可以等效为瞬时加速度的计算公式。</p><p>接下来，来看一看TressFX中的shader代码实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&#123;   // CalculateStrandLevelData</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    float4 pos_old_old[2]; // previous previous positions for vertex 0 (root) and vertex 1.</span><br><span class="line">    float4 pos_old[2]; // previous positions for vertex 0 (root) and vertex 1.</span><br><span class="line">    float4 pos_new[2]; // current positions for vertex 0 (root) and vertex 1.</span><br><span class="line"></span><br><span class="line">    pos_old_old[0] = g_HairVertexPositionsPrevPrev[globalRootVertexIndex];</span><br><span class="line">    pos_old_old[1] = g_HairVertexPositionsPrevPrev[globalRootVertexIndex + 1];</span><br><span class="line"></span><br><span class="line">    pos_old[0] = g_HairVertexPositionsPrev[globalRootVertexIndex];</span><br><span class="line">    pos_old[1] = g_HairVertexPositionsPrev[globalRootVertexIndex + 1];</span><br><span class="line"></span><br><span class="line">    pos_new[0] = g_HairVertexPositions[globalRootVertexIndex];</span><br><span class="line">    pos_new[1] = g_HairVertexPositions[globalRootVertexIndex + 1];</span><br><span class="line"></span><br><span class="line">    float3 u = normalize(pos_old[1].xyz - pos_old[0].xyz); // t1时刻（上一帧）时的u向量</span><br><span class="line">    float3 v = normalize(pos_new[1].xyz - pos_new[0].xyz); // t2时刻（当前帧）时的v向量</span><br><span class="line"></span><br><span class="line">    // Compute rotation and translation which transform pos_old to pos_new.</span><br><span class="line">    // Since the first two vertices are immovable, we can assume that there is no scaling during tranform.</span><br><span class="line">    float4 rot = QuatFromTwoUnitVectors(u, v);                                    // 根据u&amp;v向量算出旋转变化量</span><br><span class="line">    float3 trans = pos_new[0].xyz - MultQuaternionAndVector(rot, pos_old[0].xyz); // 因为有旋转的缘故，先把上一帧顶点的位置带上旋转的影响，再和当前帧顶点的位置计算出一个平移变化量</span><br><span class="line"></span><br><span class="line">    float vspCoeff = GetVelocityShockPropogation();    // TressFX的注释直译叫速度传播系数，或称“加速度影响因子”更合适，默认值从g_VSP.x中取得，该值从CPU侧送下来</span><br><span class="line">    float vspAccelThreshold  = GetVSPAccelThreshold(); // 加速度阈值，从g_VSP.y中取得，该值从CPU侧送下来</span><br><span class="line"></span><br><span class="line">    // Increate the VSP coefficient by checking pseudo-acceleration to handle over-stretching when the character moves very fast</span><br><span class="line">    float accel = length(pos_new[1] - 2.0 * pos_old[1] + pos_old_old[1]); // 应用瞬时加速度公式算出瞬时加速度</span><br><span class="line"></span><br><span class="line">    // 这里，TressFX限制当计算出的加速度过大，超过了给定的加速度阈值后，设置加速度影响因子为1.0f，即完全不影响（不计算头发的加速度影响）</span><br><span class="line">    // 我认为，这里这么设计的考虑是，假设场景中有一个传送的机关，玩家通过该机关会被传送到地图的另外一个位置上，此时会有一个非常大的位置变化，</span><br><span class="line">    // 由以上公式算出来的加速度会非常大，这会导致毛发系统此时的计算结果不可信，限制为1.0f用来规避这样的场景。</span><br><span class="line">    if (accel &gt; vspAccelThreshold) // expose this value?</span><br><span class="line">        vspCoeff = 1.0f;</span><br><span class="line"></span><br><span class="line">    // 此处的加速度和加速度影响因子也能算得上是一个小的效果优化突破口吧，当前TressFX的实现里，是一个要么1.0f，要么技美调参传下</span><br><span class="line">    // 的GetVelocityShockPropogation()给定值，我们在此处是能够细化加速度所产生的影响，进而动态调整加速度影响因子值的。</span><br><span class="line">    // 在TressFX官方给出的一篇文章里，还加上了一个低阈值：</span><br><span class="line">    // if (accel &lt; vspAccelThresholdMin) &#123; vspCoeff = 0.9f; &#125;</span><br><span class="line">    // 这是具体的项目场景限制了技美能调整的vspCoeff取值在0.0f到0.9f之间，当加速度过小时，即角色的运动状态是在匀速或者速度变化很小地移动，那么</span><br><span class="line">    // 头发不应该有过于明显的飘起效果，此时将该值设置为一个较大值，让头发的飘起效果不明显些。这个具体的判断条件之类就可以根据具体的项目需求自定义了。</span><br><span class="line"></span><br><span class="line">    // 写到g_StrandLevelData中供下一个pass用</span><br><span class="line">    g_StrandLevelData[globalStrandIndex].vspQuat = rot;</span><br><span class="line">    g_StrandLevelData[globalStrandIndex].vspTranslation = float4(trans, vspCoeff);</span><br><span class="line"></span><br><span class="line">    // 以下部分是骨骼变换带来的旋转量，也计算出来存在g_StrandLevelData中</span><br><span class="line"></span><br><span class="line">    // skinning</span><br><span class="line"></span><br><span class="line">    // Copy data into shared memory</span><br><span class="line">    float4 initialPos = g_InitialHairPositions[globalRootVertexIndex]; // rest position</span><br><span class="line"></span><br><span class="line">    // Apply bone skinning to initial position</span><br><span class="line">    BoneSkinningData skinningData = g_BoneSkinningData[globalStrandIndex];</span><br><span class="line"></span><br><span class="line">    float4 bone_quat;</span><br><span class="line">    initialPos.xyz = ApplyVertexBoneSkinning(initialPos.xyz, skinningData, bone_quat);</span><br><span class="line"></span><br><span class="line">    g_StrandLevelData[globalStrandIndex].skinningQuat = bone_quat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，我们也能知道该pass需要使用到的constant buffer中的参数了。</p><ul><li>float4 g_VSP<br>g_VSP.x: 速度传播系数&#x2F;加速度影响因子<br>g_VSP.y: 加速度阈值</li><li>int4 g_Counts<br>g_Counts.x -&gt; g_NumOfStrandsPerThreadGroup: num strands per thread group<br>g_Counts.y -&gt; g_NumFollowHairsPerGuideHair: num follow hairs per guid hair</li><li>float4x4 g_BoneSkinningMatrix数组：骨骼反向绑定矩阵</li></ul><p>其中，加速度影响因子的值TressFX默认设置为0.8f。在当前pass的shader的最后，它被一同存进了<code>g_StrandLevelData[globalStrandIndex].vspTranslation.w</code>，在下一个pass中，我们能看到，它的值越大发丝就越不容易飘起来。</p><p>第二个pass将头发附着体的变换带来的影响作用到每根头发的每个顶点上，该pass的shader入口点是VelocityShockPropagation。这个pass除了在CalcIndicesInVertexLevelMaster时用到了g_Counts这个参数，其他地方都没有再用到多的constant buffer，参数来自于上一个pass的g_StrandLevelData。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">//--------------------------------------------------------------------------------------</span><br><span class="line">//</span><br><span class="line">//  VelocityShockPropagation</span><br><span class="line">//</span><br><span class="line">//  Propagate velocity shock resulted by attached based mesh</span><br><span class="line">//</span><br><span class="line">// One thread computes one vetex.</span><br><span class="line">//</span><br><span class="line">//--------------------------------------------------------------------------------------</span><br><span class="line">[numthreads(THREAD_GROUP_SIZE, 1, 1)]</span><br><span class="line">void VelocityShockPropagation(uint GIndex : SV_GroupIndex,</span><br><span class="line">    uint3 GId : SV_GroupID, uint3 DTid : SV_DispatchThreadID)</span><br><span class="line">&#123;</span><br><span class="line">    uint globalStrandIndex, localStrandIndex, globalVertexIndex, localVertexIndex;</span><br><span class="line">    uint numVerticesInTheStrand, indexForSharedMem, strandType;</span><br><span class="line">    CalcIndicesInVertexLevelMaster(GIndex, GId.x,</span><br><span class="line">        globalStrandIndex, localStrandIndex,</span><br><span class="line">        globalVertexIndex, localVertexIndex,</span><br><span class="line">        numVerticesInTheStrand, indexForSharedMem, strandType);</span><br><span class="line"></span><br><span class="line">    if (localVertexIndex &lt; 2)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    float4 vspQuat = g_StrandLevelData[globalStrandIndex].vspQuat;</span><br><span class="line">    float4 vspTrans = g_StrandLevelData[globalStrandIndex].vspTranslation;</span><br><span class="line">    float vspCoeff = vspTrans.w;</span><br><span class="line"></span><br><span class="line">    // 在此行之上的代码就不详细注解了。这里拿到当前处理的顶点的当前帧位置和上一帧位置。</span><br><span class="line">    float4 pos_new_n = g_HairVertexPositions[globalVertexIndex];</span><br><span class="line">    float4 pos_old_n = g_HairVertexPositionsPrev[globalVertexIndex];</span><br><span class="line"></span><br><span class="line">    // 这里我们可以看到，每根头发上除了根部的两个顶点外的其他顶点，新的位置由两部分决定：</span><br><span class="line">    // 一部分是：(pos_new_n.xyz)</span><br><span class="line">    //  这一部分即当前头发顶点经过重力和全局形状约束的计算后本应该在的位置，假设该位置为P</span><br><span class="line">    // 另一部分是：(MultQuaternionAndVector(vspQuat, pos_new_n.xyz) + vspTrans.xyz)</span><br><span class="line">    //  这一部分将P带上头发附着体本身旋转和平移的位置变换，假设该位置为Q</span><br><span class="line">    // 最后，用(1.f-vspCoeff)和(vspCoeff)在这两个位置中插值作为最终值</span><br><span class="line">    pos_new_n.xyz = (1.f - vspCoeff) * pos_new_n.xyz + vspCoeff * (MultQuaternionAndVector(vspQuat, pos_new_n.xyz) + vspTrans.xyz);</span><br><span class="line">    pos_old_n.xyz = (1.f - vspCoeff) * pos_old_n.xyz + vspCoeff * (MultQuaternionAndVector(vspQuat, pos_old_n.xyz) + vspTrans.xyz);</span><br><span class="line"></span><br><span class="line">    g_HairVertexPositions[globalVertexIndex].xyz = pos_new_n.xyz;</span><br><span class="line">    g_HairVertexPositionsPrev[globalVertexIndex].xyz = pos_old_n.xyz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码片段中的注释，那么经过该pass的计算后，最新的位置应为：(1.0f-vspCoeff) * P + vspCoeff * Q</p><p>其中，P位置为发丝完全不受头发附着体的变换所影响时的位置，Q位置为把发丝与附着体间的连接当成完全的刚性连接，完全受到头发附着体的变换所影响时的位置。那么，当加速度影响因子vspCoeff越大时，发丝与附着体间的连接刚性越大，也就越不容易飘动了。当vspCoeff&#x3D;1.0f时，前面重力和全局形状约束计算的结果所乘以的系数(1.0f-vspCoeff)&#x3D;0（重力和全局形状约束不起作用），此时发丝变成了刚体，与头发附着体是完全的刚性连接（注意，虽然将vspCoeff设为1.0f时会使得重力和全局形状约束不影响发丝，发丝会跟随附着体发生刚性变换进行平移或旋转，但后续的局部形状约束、长度约束、风场模拟等仍然对发丝生效，因此，若从最终引擎呈现的效果上看，将vspCoeff设为1.0f并不会使头发完全不飘动）。</p><p>看完VSP的实现，我们其实能够知道，TressFX在处理速度变化带来的影响时，最终参与计算改变头发顶点位置的其实只有位置变化量，这种计算方式是物理不正确的，它会导致发丝拉长，后续的长度约束能在一定程度上缓解这一问题，但当头发的刚度和阻尼较小，而加速度过大，速度突变过大时，还是会有比较明显的拉长现象。</p><h3 id="局部形状约束"><a href="#局部形状约束" class="headerlink" title="局部形状约束"></a>局部形状约束</h3><p>局部形状约束计算出的是一根发丝上某个顶点（即：质点）受前后质点影响后的新位置，每根发丝都遵循弹簧质点模型，由于角色的移动带来了发丝的长度的变化，这个变化在大多数情况下使得发丝处于拉伸的状态，因此我们以拉伸状态下进行分析，可以推广到压缩时的场景。</p><p>在计算局部形状约束时我们不考虑重力作用产生的影响（重力作用已经在重力约束中计算了），且假设发丝上的每个顶点的质量都相等，我们以发根前5个顶点进行分析，后续顶点的计算可以依次推广得到。</p><p>发丝处于原长状态时，发丝根部前2个顶点为O1和O2，后3个顶点为A、B、C，发丝根部前两个顶点始终保持与角色刚性固连。当角色移动，发丝拉长，O1O2长度不变，O2A、AB、BC变长。O1、O2是固连端，我们先站在O2上分析O2A的伸长变化，当O2A的长度变化确定后，再逐段分析自由端的AB、BC的伸长变化，如下图所示，依此类推直到发尾。</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/20220622231518.jpg" alt="发丝顶点变化及约束前后展示图"></p><p>由图，O2A的伸长量为x1，由于O2和A的质量假设相同，则站在O2上看，由于O2端固连，O2顶点不会移动，但O2端和A端的弹簧伸长量应均为二分之一的x1，A点移动量应为x1，TressFX在计算时O2点保持不动，而A点仅和自由端一样移动了二分之一的x1；接下来分析自由端AB，AB的伸长量为x2，A端和B端的伸长量均为二分之一的x2，A点和B点的移动量均为二分之一的x2；在往后的BC段，B点和C点的移动量均为二分之一的x3；依此类推直至发尾。</p><p>TressFX用一个Pass来计算局部形状约束，同时会使用在计算VSP时输出的整体变换数据g_StrandLevelData。</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/TressFX_07.png" alt="局部形状约束的Pass图"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">//--------------------------------------------------------------------------------------</span><br><span class="line">//</span><br><span class="line">//  LocalShapeConstraints</span><br><span class="line">//</span><br><span class="line">//  Compute shader to maintain the local shape constraints.</span><br><span class="line">//</span><br><span class="line">// One thread computes one strand.</span><br><span class="line">//</span><br><span class="line">//--------------------------------------------------------------------------------------</span><br><span class="line">[numthreads(THREAD_GROUP_SIZE, 1, 1)]</span><br><span class="line">void LocalShapeConstraints(uint GIndex : SV_GroupIndex,</span><br><span class="line">    uint3 GId : SV_GroupID, uint3 DTid : SV_DispatchThreadID)</span><br><span class="line">&#123;</span><br><span class="line">    // 每根发丝一个线程并行计算，因为发丝的后段对前段有计算上的依赖关系，无法做顶点级别的并行</span><br><span class="line">    uint local_id, group_id, globalStrandIndex, numVerticesInTheStrand, globalRootVertexIndex, strandType;</span><br><span class="line">    CalcIndicesInStrandLevelMaster(GIndex, GId.x, globalStrandIndex, numVerticesInTheStrand, globalRootVertexIndex, strandType);</span><br><span class="line"></span><br><span class="line">    // stiffness for local shape constraints</span><br><span class="line">    float stiffnessForLocalShapeMatching = GetLocalStiffness(strandType); // GetLocalStiffness返回g_Shape.y</span><br><span class="line"></span><br><span class="line">    //1.0 for stiffness makes things unstable sometimes.</span><br><span class="line">    stiffnessForLocalShapeMatching = 0.5f*min(stiffnessForLocalShapeMatching, 0.95f); // 这里的0.5是当弹簧两端的质点质量一样时，弹簧两端的伸长量一样，均为该段总伸长量的一半</span><br><span class="line"></span><br><span class="line">    //--------------------------------------------</span><br><span class="line">    // Local shape constraint for bending/twisting</span><br><span class="line">    //--------------------------------------------</span><br><span class="line">    &#123;</span><br><span class="line">        float4 boneQuat = g_StrandLevelData[globalStrandIndex].skinningQuat; // 骨骼变换</span><br><span class="line"></span><br><span class="line">        // vertex 1 through n-1</span><br><span class="line">        // 处理的是发丝上的第2到n个顶点</span><br><span class="line">        for (uint localVertexIndex = 1; localVertexIndex &lt; numVerticesInTheStrand - 1; localVertexIndex++)</span><br><span class="line">        &#123;</span><br><span class="line">            uint globalVertexIndex = globalRootVertexIndex + localVertexIndex;</span><br><span class="line"></span><br><span class="line">            float4 pos = g_HairVertexPositions[globalVertexIndex];               // 当前顶点的位置</span><br><span class="line">            float4 pos_plus_one = g_HairVertexPositions[globalVertexIndex + 1];  // 朝发尾方向下一个顶点的位置</span><br><span class="line">            float4 pos_minus_one = g_HairVertexPositions[globalVertexIndex - 1]; // 朝发根方向上一个顶点的位置</span><br><span class="line"></span><br><span class="line">            // 当前顶点、下一个、上一个顶点的初始的世界坐标系下的位置（即带上骨骼变换）</span><br><span class="line">            float3 bindPos = MultQuaternionAndVector(boneQuat, g_InitialHairPositions[globalVertexIndex].xyz);</span><br><span class="line">            float3 bindPos_plus_one = MultQuaternionAndVector(boneQuat, g_InitialHairPositions[globalVertexIndex + 1].xyz);</span><br><span class="line">            float3 bindPos_minus_one = MultQuaternionAndVector(boneQuat, g_InitialHairPositions[globalVertexIndex - 1].xyz);</span><br><span class="line"></span><br><span class="line">            float3 lastVec = pos.xyz - pos_minus_one.xyz; // 朝发根方向上一个顶点位置至当前顶点位置的向量，上一个顶点位置处的发丝切线方向</span><br><span class="line"></span><br><span class="line">            float4 invBone = InverseQuaternion(boneQuat); // 这个变量没有用</span><br><span class="line">            float3 vecBindPose = bindPos_plus_one - bindPos;      // 当前位置处的发丝初始切线方向向量</span><br><span class="line">            float3 lastVecBindPose = bindPos - bindPos_minus_one; // 上一个顶点位置处的发丝初始切线方向向量</span><br><span class="line">            // 由上一个顶点位置处的初始切线方向向量和当前位置处的发丝初始切线方向向量计算出初始状态时的发丝旋转/扭转量</span><br><span class="line">            float4 rotGlobal = QuatFromTwoUnitVectors(normalize(lastVecBindPose), normalize(lastVec));</span><br><span class="line"></span><br><span class="line">            // vecBindPose是有大小和方向的向量，此行即：MultQuaternionAndVector(rotGlobal, (bindPos_plus_one - bindPos)) + pos.xyz</span><br><span class="line">            // 计算出的orgPos_i_plus_1_InGlobalFrame是下一个顶点在没有受到重力与全局形状约束、速度震动传播时应所在的位置</span><br><span class="line">            float3 orgPos_i_plus_1_InGlobalFrame = MultQuaternionAndVector(rotGlobal, vecBindPose) + pos.xyz;</span><br><span class="line">            // 计算(orgPos_i_plus_1_InGlobalFrame - pos_plus_one.xyz)就得到了没有受到上述约束和受到上述约束的变化量delta</span><br><span class="line">            // 乘上刚度系数就得到了局部形状约束的作用量，由于假设了发丝上各顶点的质量一致，前面已经乘过0.5了</span><br><span class="line">            float3 del = stiffnessForLocalShapeMatching * (orgPos_i_plus_1_InGlobalFrame - pos_plus_one.xyz);</span><br><span class="line"></span><br><span class="line">            if (IsMovable(pos))</span><br><span class="line">                pos.xyz -= del.xyz; // 应用到自由端的当前顶点的位置</span><br><span class="line"></span><br><span class="line">            if (IsMovable(pos_plus_one))</span><br><span class="line">                pos_plus_one.xyz += del.xyz; // 应用到自由端的下一个顶点的位置</span><br><span class="line"></span><br><span class="line">            g_HairVertexPositions[globalVertexIndex].xyz = pos.xyz;</span><br><span class="line">            g_HairVertexPositions[globalVertexIndex + 1].xyz = pos_plus_one.xyz;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/TressFX_Doc_06.png" alt="局部形状约束参考图（向量vec由pos指向pos_plus_one，向量lastVec由pos_minus_one指向pos，均为骨骼变化前的，vecBindPose和lastVecBindPose是带上骨骼变换计算后的）"></p><p>从代码中我们也能知道该pass需要使用到的constant buffer中的参数了。</p><ul><li>float4 g_Shape<br>g_Shape.y: LocalConstraintStiffness，局部形状约束的刚度值，默认为0.8f</li><li>int4 g_Counts<br>g_Counts.x -&gt; g_NumOfStrandsPerThreadGroup: num strands per thread group<br>g_Counts.y -&gt; g_NumFollowHairsPerGuideHair: num follow hairs per guid hair</li></ul><h3 id="长度约束（和风场计算）"><a href="#长度约束（和风场计算）" class="headerlink" title="长度约束（和风场计算）"></a>长度约束（和风场计算）</h3><p>从物理现象上来说，发丝的长度是定长的（肉眼感知不到），但是在前面的物理计算过程中，会导致我们的发丝长度发生改变，这种改变是非预期的，是TressFX物理计算模型的副作用，我们通过长度约束来缓解这一问题。</p><p>该过程针对每个头发模型使用1个pass进行迭代计算，分为CPU迭代和GPU迭代，CPU迭代会多次Dispatch，GPU迭代会在shader中循环重复计算。</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/TressFX_08.png" alt="长度约束的Pass图"></p><p>TressFX采用的长度约束算法如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/20220622232655.png" alt="长度约束算法"></p><p>由于假设了发丝每个顶点的质量一致，因此w均相同，约简即：</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/20220629231520.png" alt="长度约束公式"></p><p>其中li为发丝当前的长度，li0为发丝原长。</p><p>此即shader代码中ApplyDistanceConstraint函数做的事情。</p><p>我们看该算法，能够发现每次最小的约束单元计算时会改变两个顶点的位置，因此我们只能分离出奇偶部分，分别做并行处理，计算出其中一对后，先同步线程再算另一对。</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/20220622231548.jpg" alt="长度约束并行方法"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line">//--------------------------------------------------------------------------------------</span><br><span class="line">//</span><br><span class="line">//  LengthConstriantsWindAndCollision</span><br><span class="line">//</span><br><span class="line">//  Compute shader to move the vertex position based on wind, maintain the lenght constraints</span><br><span class="line">//  and handles collisions.</span><br><span class="line">//  注意！TressFX这里的碰撞处理的计算，是头发和胶囊体的碰撞计算，是一个非常简单粗糙的碰撞矫正，和基于SDF建场方法的碰撞矫正不是同一个！</span><br><span class="line">//</span><br><span class="line">// One thread computes one vertex.</span><br><span class="line">//</span><br><span class="line">//--------------------------------------------------------------------------------------</span><br><span class="line">[numthreads(THREAD_GROUP_SIZE, 1, 1)]</span><br><span class="line">void LengthConstriantsWindAndCollision(uint GIndex : SV_GroupIndex,</span><br><span class="line">    uint3 GId : SV_GroupID, uint3 DTid : SV_DispatchThreadID)</span><br><span class="line">&#123;</span><br><span class="line">    uint globalStrandIndex, localStrandIndex, globalVertexIndex, localVertexIndex, numVerticesInTheStrand, indexForSharedMem, strandType;</span><br><span class="line">    CalcIndicesInVertexLevelMaster(GIndex, GId.x, globalStrandIndex, localStrandIndex, globalVertexIndex, localVertexIndex, numVerticesInTheStrand, indexForSharedMem, strandType);</span><br><span class="line"></span><br><span class="line">    uint numOfStrandsPerThreadGroup = g_NumOfStrandsPerThreadGroup;</span><br><span class="line"></span><br><span class="line">    //------------------------------</span><br><span class="line">    // Copy data into shared memory</span><br><span class="line">    //------------------------------</span><br><span class="line">    sharedPos[indexForSharedMem] = g_HairVertexPositions[globalVertexIndex];</span><br><span class="line">    sharedLength[indexForSharedMem] = g_HairRestLengthSRV[globalVertexIndex]; // 每根发丝上两两顶点间的长度，在CPU中计算，详见后文中的列出的cpp代码。该长度也能够在GPU中通过发丝的初始顶点位置计算出来。</span><br><span class="line">    GroupMemoryBarrierWithGroupSync();</span><br><span class="line"></span><br><span class="line">    //------------</span><br><span class="line">    // Wind</span><br><span class="line">    //------------</span><br><span class="line">    // 风场计算部分放在下一节中再详细展开，这里简单看看就好</span><br><span class="line">    if ( g_Wind.x != 0 || g_Wind.y != 0 || g_Wind.z != 0 )</span><br><span class="line">    &#123;</span><br><span class="line">        float4 force = float4(0, 0, 0, 0);</span><br><span class="line"></span><br><span class="line">        float frame = g_Wind.w;</span><br><span class="line"></span><br><span class="line">        if ( localVertexIndex &gt;= 2 &amp;&amp; localVertexIndex &lt; numVerticesInTheStrand-1 )</span><br><span class="line">        &#123;</span><br><span class="line">            // combining four winds.</span><br><span class="line">            float a = ((float)(globalStrandIndex % 20))/20.0f;</span><br><span class="line">            float3  w = a*g_Wind.xyz + (1.0f-a)*g_Wind1.xyz + a*g_Wind2.xyz + (1.0f-a)*g_Wind3.xyz;</span><br><span class="line"></span><br><span class="line">            uint sharedIndex = localVertexIndex * numOfStrandsPerThreadGroup + localStrandIndex;</span><br><span class="line"></span><br><span class="line">            float3 v = sharedPos[sharedIndex].xyz - sharedPos[sharedIndex+numOfStrandsPerThreadGroup].xyz;</span><br><span class="line">            float3 force = -cross(cross(v, w), v);</span><br><span class="line">            sharedPos[sharedIndex].xyz += force*g_TimeStep*g_TimeStep;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    GroupMemoryBarrierWithGroupSync();</span><br><span class="line"></span><br><span class="line">    //----------------------------</span><br><span class="line">    // Enforce length constraints</span><br><span class="line">    //----------------------------</span><br><span class="line">    uint a = floor(numVerticesInTheStrand/2.0f);     // 发丝中间偏尾部的顶点，假设一根发丝32个顶点，则a=16</span><br><span class="line">    uint b = floor((numVerticesInTheStrand-1)/2.0f); // 发丝中部偏根部的顶点，假设一根发丝32个顶点，则a=15</span><br><span class="line"></span><br><span class="line">    // 返回g_SimInts.x，GPU中的循环迭代次数</span><br><span class="line">    int nLengthContraintIterations = GetLengthConstraintIterations();</span><br><span class="line"></span><br><span class="line">    for ( int iterationE=0; iterationE &lt; nLengthContraintIterations; iterationE++ )</span><br><span class="line">    &#123;</span><br><span class="line">        uint sharedIndex = 2*localVertexIndex * numOfStrandsPerThreadGroup + localStrandIndex;</span><br><span class="line">        // TressFX默认采用的一个THREAD_GROUP是64个线程，假设按上面的一根发丝32个顶点，那么numOfStrandsPerThreadGroup即为64/32=2</span><br><span class="line"></span><br><span class="line">        // 这儿的sharedIndex的计算和风场计算中的不同，前面多乘了一个2。</span><br><span class="line">        // 后面的代码中的两个if判断localVertexIndex&lt;a和localVertexIndex&lt;b会把后半段的发丝的顶点过滤掉，shader中只有前半段发丝顶点</span><br><span class="line">        // 所处理的线程工作（执行if中的代码），后半段发丝顶点的线程直接跳过了。</span><br><span class="line">        // 而前面多乘的一个2，会导致这些只有前半段发丝顶点会执行if中的内容的线程，实际上处理的是一根发丝上连续的奇偶两对顶点，有点绕。</span><br><span class="line"></span><br><span class="line">        // 还是按前面的假设来举个例子理解一下，一根发丝的32个顶点对应32个线程，其中只有发根的前16个顶点所对应的线程会走if里面的代码，</span><br><span class="line">        // 而这16个会走if里面的代码的线程，分别处理的是连续的奇偶两对顶点，如下：</span><br><span class="line">        // 顶点对应的线程：    t0         t1         t2         t3      ...       t13            t14        t15</span><br><span class="line">        // 处理的顶点线段： v0v1&amp;v1v2  v2v3&amp;v3v4  v4v5&amp;v5v6  v6v7&amp;v7v8  ...  v26v27&amp;v27v28  v28v29&amp;v29v30  v30v31</span><br><span class="line"></span><br><span class="line">        if( localVertexIndex &lt; a )</span><br><span class="line">            ApplyDistanceConstraint( // 对当前的顶点（偶顶点对，例如v0v1）计算长度约束，ApplyDistanceConstraint函数实现的分析见下方</span><br><span class="line">                sharedPos[sharedIndex],                            // 当前顶点</span><br><span class="line">                sharedPos[sharedIndex+numOfStrandsPerThreadGroup], // 当前顶点的下一个顶点（朝发尾方向）</span><br><span class="line">                sharedLength[sharedIndex].x);                      // 这一段的原始长度</span><br><span class="line"></span><br><span class="line">        GroupMemoryBarrierWithGroupSync(); // 务必要等同步</span><br><span class="line"></span><br><span class="line">        if( localVertexIndex &lt; b )</span><br><span class="line">            ApplyDistanceConstraint( // 对当前顶点的下一个顶点（奇顶点对，例如v1v2）计算长度约束</span><br><span class="line">                sharedPos[sharedIndex+numOfStrandsPerThreadGroup],</span><br><span class="line">                sharedPos[sharedIndex+numOfStrandsPerThreadGroup*2],</span><br><span class="line">                sharedLength[sharedIndex+numOfStrandsPerThreadGroup].x);</span><br><span class="line"></span><br><span class="line">        GroupMemoryBarrierWithGroupSync(); // 务必要等同步</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //------------------------------------------</span><br><span class="line">    // Collision handling with capsule objects</span><br><span class="line">    //------------------------------------------</span><br><span class="line">    float4 oldPos = g_HairVertexPositionsPrev[globalVertexIndex];</span><br><span class="line">    // 简单粗糙的一个与胶囊体的碰撞矫正，用基于SDF的碰撞矫正后其实不需要它的，略，对ResolveCapsuleCollisions感兴趣可以详见：</span><br><span class="line">    // https://github.com/GPUOpen-Effects/TressFX/blob/v4.1.0/src/Shaders/TressFXSimulation.hlsl#L831-L863</span><br><span class="line">    bool bAnyColDetected = ResolveCapsuleCollisions(sharedPos[indexForSharedMem], oldPos);</span><br><span class="line">    GroupMemoryBarrierWithGroupSync();</span><br><span class="line"></span><br><span class="line">    //-------------------</span><br><span class="line">    // Compute tangent</span><br><span class="line">    //-------------------</span><br><span class="line">    // If this is the last vertex in the strand, we can&#x27;t get tangent from subtracting from the next vertex, need to use last vertex to current</span><br><span class="line">    // 计算发丝顶点的切线方向，这个切线方向会作为后面头发渲染时所使用的顶点切线。计算过程也很简单，就是用下一个顶点位置减去当前的顶点位置然后</span><br><span class="line">    // normalize后得到的单位向量。对于发丝末尾的最后一个顶点，它没有下一个顶点了，就让这个末尾顶点的切线方向和倒数第二个的顶点的切线向量保持一致。</span><br><span class="line">    uint indexForTangent = (localVertexIndex == numVerticesInTheStrand - 1) ? indexForSharedMem - numOfStrandsPerThreadGroup : indexForSharedMem;</span><br><span class="line">    float3 tangent = sharedPos[indexForTangent + numOfStrandsPerThreadGroup].xyz - sharedPos[indexForTangent].xyz;</span><br><span class="line">    g_HairVertexTangents[globalVertexIndex].xyz = normalize(tangent);</span><br><span class="line"></span><br><span class="line">    //---------------------------------------</span><br><span class="line">    // clamp velocities, rewrite history</span><br><span class="line">    //---------------------------------------</span><br><span class="line">    float3 positionDelta = sharedPos[indexForSharedMem].xyz - oldPos;</span><br><span class="line">    float speedSqr = dot(positionDelta, positionDelta);</span><br><span class="line">    if (speedSqr &gt; g_ClampPositionDelta * g_ClampPositionDelta) &#123;</span><br><span class="line">        positionDelta *= g_ClampPositionDelta * g_ClampPositionDelta / speedSqr;</span><br><span class="line">        g_HairVertexPositionsPrev[globalVertexIndex].xyz = sharedPos[indexForSharedMem].xyz - positionDelta; // 处理的是上一帧的顶点位置</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //---------------------------------------</span><br><span class="line">    // update global position buffers</span><br><span class="line">    //---------------------------------------</span><br><span class="line">    g_HairVertexPositions[globalVertexIndex] = sharedPos[indexForSharedMem];</span><br><span class="line"></span><br><span class="line">    if (bAnyColDetected)</span><br><span class="line">        g_HairVertexPositionsPrev[globalVertexIndex] = sharedPos[indexForSharedMem];</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ApplyDistanceConstraint(inout float4 pos0, inout float4 pos1, float targetDistance, float stiffness = 1.0)</span><br><span class="line">                                                                                        // TressFX没有放开stiffness的调整，始终是1.0</span><br><span class="line">&#123;   // 应用长度约束的算法，对照的就是前面的算法公式实现</span><br><span class="line">    float3 delta = pos1.xyz - pos0.xyz;</span><br><span class="line">    float distance = max(length(delta), 1e-7);</span><br><span class="line">    float stretching = 1 - targetDistance / distance;</span><br><span class="line">    delta = stretching * delta;</span><br><span class="line"></span><br><span class="line">    float2 multiplier = ConstraintMultiplier(pos0, pos1); // 见下方，很容易理解</span><br><span class="line"></span><br><span class="line">    pos0.xyz += multiplier[0] * delta * stiffness;</span><br><span class="line">    pos1.xyz -= multiplier[1] * delta * stiffness;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float2 ConstraintMultiplier(float4 particle0, float4 particle1)</span><br><span class="line">&#123;</span><br><span class="line">    if (IsMovable(particle0))</span><br><span class="line">    &#123;</span><br><span class="line">        if (IsMovable(particle1))</span><br><span class="line">            return float2(0.5, 0.5); // 如果两端顶点都可以移动，就均分约束带来的调整量</span><br><span class="line">        else</span><br><span class="line">            return float2(1, 0);     // 如果只有一端顶点可以移动，就把调整量全部算在这个顶点上</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        if (IsMovable(particle1))</span><br><span class="line">            return float2(0, 1);     // 理论上来说，不会走到这个分支</span><br><span class="line">        else</span><br><span class="line">            return float2(0, 0);     // 两端顶点都不可动，不调整了</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ComputeRestLengths函数在CPU中计算的每根发丝上两两顶点间的长度，这个长度也能够在GPU中通过发丝的初始顶点位置数据计算出来的，但是TressFX还是在CPU上预先计算好了，下发给GPU中直接使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TressFXAsset::ComputeRestLengths</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector3* pos = (Vector3*)m_positions.<span class="built_in">data</span>();</span><br><span class="line">    <span class="type">float</span>* restLen = (<span class="type">float</span>*)m_restLengths.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calculate rest lengths</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_numTotalStrands; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> indexRootVert = i * m_numVerticesPerStrand;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m_numVerticesPerStrand - <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            restLen[index++] = (pos[indexRootVert + j] - pos[indexRootVert + j + <span class="number">1</span>]).<span class="built_in">Length</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Since number of edges are one less than number of vertices in hair strand, below</span></span><br><span class="line">        <span class="comment">// line acts as a placeholder.</span></span><br><span class="line">        restLen[index++] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该pass只用到的一个新的constant buffer中的参数g_SimInts.x：</p><ul><li>float4 g_SimInts<br>g_SimInts.x: GPU中的循环迭代次数</li><li>int4 g_Counts<br>g_Counts.x -&gt; g_NumOfStrandsPerThreadGroup: num strands per thread group<br>g_Counts.y -&gt; g_NumFollowHairsPerGuideHair: num follow hairs per guid hair</li></ul><h2 id="风场计算"><a href="#风场计算" class="headerlink" title="风场计算"></a>风场计算</h2><p>风场计算处理的是毛发在有风的环境下的效果，如自然风、吹风机等影响下毛发的表现。风场采用的是如下所示的四棱锥风场，TressFX称它为pyramid wind（金字塔风）。</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/TressFX_Doc_07.png" alt="四棱锥风场"></p><p>风场计算的Shader代码在前一节中我们已经看到过了，这里再单独拿出来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">if ( localVertexIndex &gt;= 2 &amp;&amp; localVertexIndex &lt; numVerticesInTheStrand-1 )</span><br><span class="line">&#123;</span><br><span class="line">    // combining four winds.</span><br><span class="line">    float a = ((float)(globalStrandIndex % 20))/20.0f;</span><br><span class="line">    float3  w = a*g_Wind.xyz + (1.0f-a)*g_Wind1.xyz + a*g_Wind2.xyz + (1.0f-a)*g_Wind3.xyz;</span><br><span class="line"></span><br><span class="line">    uint sharedIndex = localVertexIndex * numOfStrandsPerThreadGroup + localStrandIndex;</span><br><span class="line"></span><br><span class="line">    float3 v = sharedPos[sharedIndex].xyz - sharedPos[sharedIndex+numOfStrandsPerThreadGroup].xyz;</span><br><span class="line">    float3 force = -cross(cross(v, w), v);</span><br><span class="line">    sharedPos[sharedIndex].xyz += force*g_TimeStep*g_TimeStep;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>对应的算法方程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/20220622233448.png" alt="风场算法"></p><p>TressFX为了在这个风场的四棱锥中“随机均匀”地生成一个风的方向，引入了一个a，并且用求20的余数的方式（发丝上顶点数量不会是20的倍数）生成一个极其简单的假随机数，然后与四棱锥的四条边方向做blend，得到一个在四棱锥风场范围内的一个风向，用这个融合风向作为当前顶点的风场计算时的风向。</p><p>TressFX把风的计算放在了和长度约束共同的一个Pass中，这个合并到一个Pass中的做法我没有想明白是为什么，长度约束有迭代次数，会根据迭代次数多次Dispatch这一个Pass，而风场计算放在这个Pass中会导致风场的计算也被计算了多次，然而g_TimeStep并不会除以迭代次数，这样就会造成风场计算跳帧了。我认为应该将风场计算单独成一个Pass进行处理。</p><p>另外，在计算在风的作用下引起的毛发顶点的位移量时，用了毛发的切线方向向量v与风的方向向量w做叉积，再与毛发的切线方向v做叉积，得到最终的位移方向，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/20220622231542.jpg" alt="计算风场影响下的发丝顶点位移方向"></p><p>这个方向计算出来是对的，但是TressFX把这个向量的xyz大小直接作为了风力影响的大小，而叉积计算结果的xyz大小值（注意这不是模）是没有实际的物理意义的，这就导致了TressFX中的风场是坏的，没有效果，我们得将它分离开，风力大小和方向得分别计算，然后再叠加。该问题已向开源仓反馈：<a href="https://github.com/GPUOpen-Effects/TressFX/issues/47">https://github.com/GPUOpen-Effects/TressFX/issues/47</a>。修改完后的Shader如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">if ( localVertexIndex &gt;= 2 &amp;&amp; localVertexIndex &lt; numVerticesInTheStrand-1 )</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    float3 v = sharedPos[sharedIndex].xyz - sharedPos[sharedIndex+numOfStrandsPerThreadGroup].xyz;</span><br><span class="line">    float force_mul = length(v) * length(w); // FIXBUG!! 分离出大小</span><br><span class="line">    v = normalize(v); // FIXBUG!! 用normalize的向量计算</span><br><span class="line">    w = normalize(w); // FIXBUG!! 用normalize的向量计算</span><br><span class="line"></span><br><span class="line">    float3 force = -cross(cross(v, w), v);</span><br><span class="line">    force *= force_mul; // FIXBUG!! 把大小和方向再组合</span><br><span class="line">    sharedPos[sharedIndex].xyz += force*g_TimeStep*g_TimeStep; // 简单地用风力乘以时间间隔片的平方作为最终的移动量大小，我理解这不是物理正确的</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在Shader中，我们直接使用了W1~W4四个向量（Shader中为g_Wind、g_Wind1、g_Wind2、g_Wind3），对应于四棱锥风场的四个边，而最外层给技美调整的接口只有风的大小方向和范围角度，这四个向量将在CPU侧通过风的方向和范围角度来生成，如下代码所示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////////////////// Quaternion.cpp ////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置当前的四元数的值为：绕axis轴旋转angle_radian弧度的四元数改变量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Quaternion::SetRotation</span><span class="params">(<span class="type">const</span> Vector3&amp; axis, <span class="type">float</span> angle_radian)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// This function assumes that the axis vector has been normalized.</span></span><br><span class="line">    <span class="type">float</span> halfAng = <span class="number">0.5f</span> * angle_radian;</span><br><span class="line">    <span class="type">float</span> sinHalf = <span class="built_in">sin</span>(halfAng);</span><br><span class="line">    w             = <span class="built_in">cos</span>(halfAng);</span><br><span class="line">    x = sinHalf * axis.x;</span><br><span class="line">    y = sinHalf * axis.y;</span><br><span class="line">    z = sinHalf * axis.z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////// TressFXHairObject.cpp ////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TressFXHairObject::SetWind</span><span class="params">(<span class="type">const</span> Vector3&amp; windDir, <span class="type">float</span> windMag, <span class="type">int</span> frame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> wM = windMag * (<span class="built_in">pow</span>(<span class="built_in">sin</span>(frame * <span class="number">0.01f</span>), <span class="number">2.0f</span>) + <span class="number">0.5f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">Vector3 <span class="title">windDirN</span><span class="params">(windDir)</span></span>;</span><br><span class="line">    windDirN.<span class="built_in">Normalize</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">Vector3 <span class="title">XAxis</span><span class="params">(<span class="number">1.0f</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    Vector3 xCrossW = XAxis.<span class="built_in">Cross</span>(windDirN);</span><br><span class="line"></span><br><span class="line">    Quaternion rotFromXAxisToWindDir;</span><br><span class="line">    rotFromXAxisToWindDir.<span class="built_in">SetIdentity</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> angle = <span class="built_in">asin</span>(xCrossW.<span class="built_in">Length</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (angle &gt; <span class="number">0.001</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 计算出从X轴方向XAxis旋转到风的方向windDirN所需要的旋转改变量并存到rotFromXAxisToWindDir中</span></span><br><span class="line">        rotFromXAxisToWindDir.<span class="built_in">SetRotation</span>(xCrossW.<span class="built_in">Normalize</span>(), angle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：风的范围角度，决定了四棱锥风场的张角，应该暴露出去给技美调参的，但是这一项TressFX的Demo写死了</span></span><br><span class="line">    <span class="type">float</span> angleToWideWindCone = <span class="built_in">DEG_TO_RAD2</span>(<span class="number">40.f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算出并更新四棱锥风场的四条棱到constant buffer，SetWindCorner函数详见下方，TressFX的计算思想是：</span></span><br><span class="line">    <span class="comment">// 以X轴的方向先应用风的范围角度，得到相对于X轴的四条棱向量，再将四条棱向量旋转到风的方向</span></span><br><span class="line">    <span class="built_in">SetWindCorner</span>(rotFromXAxisToWindDir,</span><br><span class="line">        <span class="built_in">Vector3</span>(<span class="number">0</span>, <span class="number">1.0</span>, <span class="number">0</span>),</span><br><span class="line">        angleToWideWindCone,</span><br><span class="line">        wM,</span><br><span class="line">        m_SimCB[m_SimulationFrame % <span class="number">2</span>]-&gt;m_Wind);</span><br><span class="line">    <span class="built_in">SetWindCorner</span>(rotFromXAxisToWindDir,</span><br><span class="line">        <span class="built_in">Vector3</span>(<span class="number">0</span>, <span class="number">-1.0</span>, <span class="number">0</span>),</span><br><span class="line">        angleToWideWindCone,</span><br><span class="line">        wM,</span><br><span class="line">        m_SimCB[m_SimulationFrame % <span class="number">2</span>]-&gt;m_Wind1);</span><br><span class="line">    <span class="built_in">SetWindCorner</span>(rotFromXAxisToWindDir,</span><br><span class="line">        <span class="built_in">Vector3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1.0</span>),</span><br><span class="line">        angleToWideWindCone,</span><br><span class="line">        wM,</span><br><span class="line">        m_SimCB[m_SimulationFrame % <span class="number">2</span>]-&gt;m_Wind2);</span><br><span class="line">    <span class="built_in">SetWindCorner</span>(rotFromXAxisToWindDir,</span><br><span class="line">        <span class="built_in">Vector3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1.0</span>),</span><br><span class="line">        angleToWideWindCone,</span><br><span class="line">        wM,</span><br><span class="line">        m_SimCB[m_SimulationFrame % <span class="number">2</span>]-&gt;m_Wind3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fourth component unused. (used to store frame number, but no longer used).</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wind is in a pyramid around the main wind direction.</span></span><br><span class="line"><span class="comment">// To add a random appearance, the shader will sample some direction</span></span><br><span class="line"><span class="comment">// within this cone based on the strand index.</span></span><br><span class="line"><span class="comment">// This function computes the vector for each edge of the pyramid.</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">SetWindCorner</span><span class="params">(Quaternion rotFromXAxisToWindDir,</span></span></span><br><span class="line"><span class="params"><span class="function">                          Vector3 rotAxis,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">float</span> angleToWideWindCone,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">float</span> wM,</span></span></span><br><span class="line"><span class="params"><span class="function">                          AMD::float4&amp; outVec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">const</span> Vector3 <span class="title">XAxis</span><span class="params">(<span class="number">1.0f</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">Quaternion <span class="title">rot</span><span class="params">(rotAxis, angleToWideWindCone)</span></span>;</span><br><span class="line">    Vector3    newWindDir = rotFromXAxisToWindDir * rot * XAxis;</span><br><span class="line">    outVec.x = newWindDir.x * wM;</span><br><span class="line">    outVec.y = newWindDir.y * wM;</span><br><span class="line">    outVec.z = newWindDir.z * wM;</span><br><span class="line">    outVec.w = <span class="number">0</span>;  <span class="comment">// unused.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，TressFX还在风的大小上做了点手脚，通过当前的帧数来计算一个sin函数，使得给定大小的风在一定的强度范围内有一个小波动，用来增强真实感，如下代码所示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TressFXHairObject::SetWind</span><span class="params">(<span class="type">const</span> Vector3&amp; windDir, <span class="type">float</span> windMag, <span class="type">int</span> frame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> wM = windMag * (<span class="built_in">pow</span>(<span class="built_in">sin</span>(frame * <span class="number">0.01f</span>), <span class="number">2.0f</span>) + <span class="number">0.5f</span>); <span class="comment">// sin的平方，0~1 --&gt; windMag * (0.5~1.5)范围内波动</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看了风场计算的算法，我们其实能知道，这种做法其实不是物理正确的，只是一种简单的替代实现方案。正常来说，力的解算一般在物理计算中靠前的位置，我理解在这里应该是放在重力解算之后就做风力的解算，但正是因为这只是个简单的方案，可以不用考虑这个问题。</p><h2 id="引导发丝生成从属发丝"><a href="#引导发丝生成从属发丝" class="headerlink" title="引导发丝生成从属发丝"></a>引导发丝生成从属发丝</h2><p>这一步很简单了，单纯地由引导发丝生成从属发丝，增多发丝的数量。前面的计算仅针对了引导发丝，这一步通过加一个偏移来生成更多的从属发丝。</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/TressFX_Doc_08.jpg" alt="由guide hair(粗线)生成follow hair(细线)"></p><p>TressFX用一个Pass来做这个生成动作。</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/TressFX_09.png" alt="引导发丝生成从属发丝的Pass图"></p><p>每个线程处理一根引导发丝上的一个顶点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// One thread computes one vertex.</span><br><span class="line">[numthreads(THREAD_GROUP_SIZE, 1, 1)]</span><br><span class="line">void UpdateFollowHairVertices(uint GIndex : SV_GroupIndex,</span><br><span class="line">    uint3 GId : SV_GroupID, uint3 DTid : SV_DispatchThreadID)</span><br><span class="line">&#123;</span><br><span class="line">    uint globalStrandIndex, localStrandIndex, globalVertexIndex, localVertexIndex;</span><br><span class="line">    uint numVerticesInTheStrand, indexForSharedMem, strandType;</span><br><span class="line">    CalcIndicesInVertexLevelMaster(GIndex, GId.x,</span><br><span class="line">        globalStrandIndex, localStrandIndex,</span><br><span class="line">        globalVertexIndex, localVertexIndex,</span><br><span class="line">        numVerticesInTheStrand, indexForSharedMem, strandType);</span><br><span class="line"></span><br><span class="line">    sharedPos[indexForSharedMem] = g_HairVertexPositions[globalVertexIndex];    // 引导发丝的position</span><br><span class="line">    sharedTangent[indexForSharedMem] = g_HairVertexTangents[globalVertexIndex]; // 引导发丝的tangent</span><br><span class="line">    GroupMemoryBarrierWithGroupSync();</span><br><span class="line"></span><br><span class="line">    for ( uint i = 0; i &lt; g_NumFollowHairsPerGuideHair; i++ ) // 每根从属发丝遍历</span><br><span class="line">    &#123;</span><br><span class="line">        int globalFollowVertexIndex = globalVertexIndex + numVerticesInTheStrand * (i + 1);</span><br><span class="line">        int globalFollowStrandIndex = globalStrandIndex + i + 1;</span><br><span class="line"></span><br><span class="line">        // g_TipSeparationFactor是技美给定的头发尾端的间隔影响因子，</span><br><span class="line">        // 由(localVertexIndex / numVerticesInTheStrand)的计算我们可知，越靠近发丝的根部，影响越小，发根第一个顶点一般在附着体上，</span><br><span class="line">        // localVertexIndex为0，不受影响，越靠近发丝的尾部，影响越大。这个效果类似于一个毛囊里一般生有多根毛发（人头1个毛囊一般2~3根头发）</span><br><span class="line">        // 加了个1.0，确保比1.0大，TipSeparationFactor一般在(0.0f, 1.0f)范围内调整，较浓密的毛发一般取值0.1f左右即可，稀疏的毛发可以增大该值</span><br><span class="line">        float factor = g_TipSeparationFactor*((float)localVertexIndex / (float)numVerticesInTheStrand) + 1.0f;</span><br><span class="line">        // g_FollowHairRootOffset是在CPU上生成的随机均匀的偏移量，该偏移量乘以上一行计算出的影响因子，得到该发丝上的该顶点的最终偏移量</span><br><span class="line">        float3 followPos = sharedPos[indexForSharedMem].xyz + factor*g_FollowHairRootOffset[globalFollowStrandIndex].xyz;</span><br><span class="line">        g_HairVertexPositions[globalFollowVertexIndex].xyz = followPos;</span><br><span class="line"></span><br><span class="line">        g_HairVertexTangents[globalFollowVertexIndex] = sharedTangent[indexForSharedMem];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Shader中我们需要g_FollowHairRootOffset这个在CPU上生成的针对每根发丝每个顶点的随机均匀偏移量。由引导发丝生成的从属发丝，它们所在的位置一定是与引导发丝近似平行的。因此，我们需要计算出引导发丝的上的每个顶点的切线方向，用来指导生成对应的从属发丝的顶点。</p><p>如下代码所示，g_FollowHairRootOffset的生成在TressFXAsset::GenerateFollowHairs函数中进行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TressFXAsset::GenerateFollowHairs</span><span class="params">(<span class="type">int</span> numFollowHairsPerGuideHair, <span class="type">float</span> tipSeparationFactor, <span class="type">float</span> maxRadiusAroundGuideHair)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    m_followRootOffsets.<span class="built_in">resize</span>(m_numTotalStrands);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// type-cast to Vector3 to handle data easily. </span></span><br><span class="line">    Vector3* pos = m_positions.<span class="built_in">data</span>();</span><br><span class="line">    Vector3* followOffset = m_followRootOffsets.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Generate follow hairs</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_numGuideStrands; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> indexGuideStrand = i * (m_numFollowStrandsPerGuide + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> indexRootVertMaster = indexGuideStrand * m_numVerticesPerStrand;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;pos[indexRootVertMaster], &amp;positionsGuide[i*m_numVerticesPerStrand], <span class="built_in">sizeof</span>(Vector3)*m_numVerticesPerStrand);</span><br><span class="line">        m_strandUV[indexGuideStrand] = strandUVGuide[i];</span><br><span class="line"></span><br><span class="line">        followOffset[indexGuideStrand].<span class="built_in">Set</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);                <span class="comment">// guide hair不需要偏移</span></span><br><span class="line">        followOffset[indexGuideStrand].w = (<span class="type">float</span>)indexGuideStrand; <span class="comment">// 当前的followRootOffset所属的发丝id</span></span><br><span class="line"></span><br><span class="line">        Vector3 v01 = pos[indexRootVertMaster + <span class="number">1</span>] - pos[indexRootVertMaster]; <span class="comment">// 切线方向</span></span><br><span class="line">        v01.<span class="built_in">Normalize</span>();                                                       <span class="comment">// normalize后得到切线方向单位向量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find two orthogonal unit tangent vectors to v01</span></span><br><span class="line">        Vector3 t0, t1;</span><br><span class="line">        <span class="built_in">GetTangentVectors</span>(v01, t0, t1);</span><br><span class="line">        <span class="comment">// GetTangentVectors将发丝顶点处的切线方向单位向量转成正交系下的两个分量，GetTangentVectors函数详见：</span></span><br><span class="line">        <span class="comment">// https://github.com/GPUOpen-Effects/TressFX/blob/v4.1.0/src/TressFX/TressFXAsset.cpp#L37-L63</span></span><br><span class="line">        <span class="comment">// 我们只有在正交系下才能表征和计算出平行于切线方向的偏移量</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m_numFollowStrandsPerGuide; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> indexStrandFollow = indexGuideStrand + j + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> indexRootVertFollow = indexStrandFollow * m_numVerticesPerStrand;</span><br><span class="line"></span><br><span class="line">            m_strandUV[indexStrandFollow] = m_strandUV[indexGuideStrand];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// offset vector from the guide strand&#x27;s root vertex position</span></span><br><span class="line">            Vector3 offset = <span class="built_in">GetRandom</span>(-maxRadiusAroundGuideHair, maxRadiusAroundGuideHair) * t0 +</span><br><span class="line">            <span class="built_in">GetRandom</span>(-maxRadiusAroundGuideHair, maxRadiusAroundGuideHair) * t1;</span><br><span class="line">                             <span class="comment">// GetRandom函数：static float GetRandom(float Min, float Max) &#123; </span></span><br><span class="line">                             <span class="comment">//                 return ((float(rand()) / float(RAND_MAX)) * (Max - Min)) + Min; &#125;</span></span><br><span class="line">            <span class="comment">// 分解成正交系下的u(t0)、v(t1)，就可以分别对uv方向取随机的偏移了，偏移值的范围在正负maxRadiusAroundGuideHair之间，</span></span><br><span class="line">            <span class="comment">// 这样就能保证生成出的从属发丝在极差maxRadiusAroundGuideHair范围内平行于引导发丝</span></span><br><span class="line">            followOffset[indexStrandFollow] = offset;</span><br><span class="line">            followOffset[indexStrandFollow].w = (<span class="type">float</span>)indexGuideStrand; <span class="comment">// 当前的followRootOffset所属的发丝id</span></span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>在写这篇文章的时候，发现TressFX 5.0版本在5月底的时候发布了，但是它不再作为单独的项目仓发布了，而是做成了UE4的patch，直接打到UE4的源码里，开源在<a href="https://github.com/GPUOpenSoftware/UnrealEngine/tree/TressFX5-4.27">https://github.com/GPUOpenSoftware/UnrealEngine/tree/TressFX5-4.27</a>。</p><p>TressFX的这次更新最主要的看点在支持了Marschner光照模型、增加了TAA时间抗锯齿、做了阴影的优化。</p><p>有时间和机会我们再去扒一扒他们新的实现，看看都做了啥:-)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;毛发物理模拟算法分析&quot;&gt;&lt;a href=&quot;#毛发物理模拟算法分析&quot; class=&quot;headerlink&quot; title=&quot;毛发物理模拟算法分析&quot;&gt;&lt;/a&gt;毛发物理模拟算法分析&lt;/h1&gt;&lt;p&gt;本文仅在个人博客及个人知乎上采用”CC BY-NC-ND 4.0”(署名-不</summary>
      
    
    
    
    <category term="开发杂记" scheme="https://blog.kdyx.net/categories/%E5%BC%80%E5%8F%91%E6%9D%82%E8%AE%B0/"/>
    
    <category term="CV/CG" scheme="https://blog.kdyx.net/categories/%E5%BC%80%E5%8F%91%E6%9D%82%E8%AE%B0/CV-CG/"/>
    
    
    <category term="Hair" scheme="https://blog.kdyx.net/tags/Hair/"/>
    
    <category term="毛发渲染" scheme="https://blog.kdyx.net/tags/%E6%AF%9B%E5%8F%91%E6%B8%B2%E6%9F%93/"/>
    
    <category term="物理模拟" scheme="https://blog.kdyx.net/tags/%E7%89%A9%E7%90%86%E6%A8%A1%E6%8B%9F/"/>
    
    <category term="数字人" scheme="https://blog.kdyx.net/tags/%E6%95%B0%E5%AD%97%E4%BA%BA/"/>
    
    <category term="发丝" scheme="https://blog.kdyx.net/tags/%E5%8F%91%E4%B8%9D/"/>
    
    <category term="TressFX" scheme="https://blog.kdyx.net/tags/TressFX/"/>
    
  </entry>
  
  <entry>
    <title>保姆级毛发算法调研分析，十万长文带你深入TressFX（一）</title>
    <link href="https://blog.kdyx.net/blog/kongdeyou/hair_simulation_and_rendering/"/>
    <id>https://blog.kdyx.net/blog/kongdeyou/hair_simulation_and_rendering/</id>
    <published>2022-05-29T13:40:12.000Z</published>
    <updated>2024-04-04T03:53:39.524Z</updated>
    
    <content type="html"><![CDATA[<h1 id="毛发算法调研分析"><a href="#毛发算法调研分析" class="headerlink" title="毛发算法调研分析"></a>毛发算法调研分析</h1><p><strong>开篇</strong></p><p>该系列的文章主要记录我在研究和实现毛发算法的历程。</p><p>本文仅在个人博客及个人知乎上采用”CC BY-NC-ND 4.0”(署名-不可商用-禁止演绎)协议发布，转载请注明个人博客的原文链接及作者信息，侵权必究。</p><p>博客链接：<a href="https://tis.ac.cn/blog/kongdeyou/hair_simulation_and_rendering/">https://tis.ac.cn/blog/kongdeyou/hair_simulation_and_rendering/</a></p><p>知乎链接：<a href="https://zhuanlan.zhihu.com/p/517553643/">https://zhuanlan.zhihu.com/p/517553643/</a></p><p><strong>目录</strong></p><p>本文的目录结构如下：</p><p>[toc]</p><p>本系列后续文章中会陆续记录算法细节。</p><p>看完这一系列文章后，我们能够：</p><ul><li>对毛发系统有一个完整的概念</li><li>深入毛发系统的核心实现算法</li><li>在自己的引擎中实现毛发系统</li></ul><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>2022年春节回来后，我就一直在做毛发的调研分析和集成实现的工作，前前后后捣鼓了有三四个月，自己都快没有头发了（大概是<del>极限一换一，我和模型只能有一个有头发了</del>（我没有、我不是，我头发很浓密的！））。言归正传，此次调研的目的是沿着前人的足迹，走出一条落地的通路，然后再把路一点点拓宽:-)</p><h3 id="毛发系统"><a href="#毛发系统" class="headerlink" title="毛发系统"></a>毛发系统</h3><p>毛发系统由<strong>毛发渲染</strong>和<strong>物理模拟</strong>组成。</p><p>早期的毛发系统仅负责毛发的渲染，毛发的物理模拟通过物理引擎中的绳子模型或刚体的弹簧质点约束进行简单的等效。</p><p>后来逐渐发展出发丝模型后，毛发系统开始有了自己独立的毛发物理模拟算法，毛发的物理模拟不再借用通用的物理引擎中。</p><p>按我的<del>理解</del>（其实就是技术洁癖），毛发的物理模拟最终最优雅的形态还是放在物理引擎中的，这样物理引擎内场景能够归一，比如物理场景中有风场，那么如果按照当前的架构形态，毛发系统接管了毛发的物理模拟，那么就得在物理引擎中和毛发系统的物理模拟中分别加上这个风场的影响，一个风场得改两处，其他的功能也得两边分别处理，对引擎来说不便于维护。当然，我针对的是物理引擎是纯自研的情景，如果本身已经是“缝合怪”，物理引擎是引用的开源组件，那么还是不要侵入式修改加上毛发的物理模拟功能为好，把它老老实实放在毛发系统中吧。</p><h3 id="毛发模型发展史"><a href="#毛发模型发展史" class="headerlink" title="毛发模型发展史"></a>毛发模型发展史</h3><p>头发模型的发展过程主要经过了三个阶段：</p><ol><li>整头头发模型<br><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/HairModel_01.png" alt="整头模型图-图源来自网络"><br>这是最早的头发模型，整头头发部分是一个大的Mesh，直接盖在角色的头部模型之上。这种方式的头发模型制作简单，渲染也简单，实现不了精细的毛发渲染，也无法做物理模拟。</li><li>发片模型<br><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/HairModel_02.png" alt="发片模型图-图源来自网络"><br>算力的提升带来了新的头发建模方法，发片模型是基于一撮撮头发进行建模的，头发由一系列的Triangle List组成，每撮头发是一个Triangle List，然后在这个Triangle List上贴上头发的Albedo贴图，用alpha blend来将Triangle List上有头发的地方透出来，实现最终的头发渲染。<br>发片模型制作难度适中，能够进行头发材质的渲染，但是这种模型的问题在于难以进行精细的物理模拟。</li><li>发丝模型<br><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/HairModel_03.png" alt="发丝模型图-图源来自网络"><br>发丝模型即只制作每根头发的引导线，在交给引擎进行头发渲染时再由引擎根据发丝的引导线生成每根头发的Triangle List。发丝模型的出现是为了解决头发物理模拟的问题的，从渲染角度上看，发片和发丝都可以让技美“精细化作业”来实现渲染出类似的效果，但发丝模型能很好地做物理计算，实现头发的海飞丝效果。<br>发丝模型制作复杂，需要美工针对头部模型上对每根头发进行种植，在没有物理计算时会成“爆炸头”，有特别的头发形状的，还得要求美工种植的发丝模型每根都是已经做好弯曲定型的，加大美工的操作难度。</li></ol><p>目前大多数的场景下还是以发片模型为主，一是手游市场上的手机平台性能有限，基于每根发丝的头发物理模拟和运行时每帧生成头发的三角形面片手机吃不消，而发丝的主要优势在物理模拟上，渲染上发片和发丝都能做出比较好的效果，二是目前除了数字人的场景，大多数的场景对人物模型的要求都不高，非3A级大作的核心是玩法足够吸引玩家，投资方能够尽快产生收益，非写实风的人物也不需要在头发上深挖物理模拟的细节，简单使用物理引擎进行粗粒度的等效即可。</p><h3 id="毛发算法发展史"><a href="#毛发算法发展史" class="headerlink" title="毛发算法发展史"></a>毛发算法发展史</h3><p><strong>物理算法</strong></p><p>毛发的物理算法没有一条清晰的发展脉络线，各家算法本质上都是基于弹簧质点系统的不断细化和改进。由于头发物理模拟的巨大计算量，实现完全物理正确的头发模拟的开销十分巨大且没有必要，因此在毛发的物理计算中常常采用简化的建模模型（所谓“简化”相对于其他的物理模拟来说还是复杂的）。</p><p><strong>渲染算法</strong></p><ol><li>Kajiya-Kay Model<br>相关文章：<a href="https://www.cs.drexel.edu/~david/Classes/CS586/Papers/p271-kajiya.pdf">https://www.cs.drexel.edu/~david/Classes/CS586/Papers/p271-kajiya.pdf</a></li><li>Marschner Model<br>相关文章：<a href="https://graphics.stanford.edu/papers/hair/hair-sg03final.pdf">https://graphics.stanford.edu/papers/hair/hair-sg03final.pdf</a></li><li>Scheuermann Model（结合了Marschner的结论，在Kajiya的基础之上为实时渲染而设计，又称kajiya+）<br>相关文章1(相似文章)：<a href="https://developer.amd.com/wordpress/media/2012/10/Scheuermann_HairRendering.pdf">https://developer.amd.com/wordpress/media/2012/10/Scheuermann_HairRendering.pdf</a><br>相关文章2(相似文章)：<a href="https://developer.amd.com/wordpress/media/2012/10/Scheuermann_HairSketchSlides.pdf">https://developer.amd.com/wordpress/media/2012/10/Scheuermann_HairSketchSlides.pdf</a></li><li>d’Eon Model（在Marschner上进一步考虑把头发分成两层，内部再次计算一次散射，效果提升不大，又称Marschner+）<br>相关文章：<a href="http://www.eugenedeon.com/wp-content/uploads/2014/04/egsrhair.pdf">http://www.eugenedeon.com/wp-content/uploads/2014/04/egsrhair.pdf</a></li></ol><p>后续的算法基本都是基于Kajiya和Marschner的改进和补充。Kajiya光照模型给我们提供了一套物理不正确、但计算速度快的廉价方案，而Marschner是基于真实的发丝物理结构，进行测算后建模形成的光照模型，物理真实性更高，但计算量相比起来也会大些。</p><h3 id="毛发物理算法简析"><a href="#毛发物理算法简析" class="headerlink" title="毛发物理算法简析"></a>毛发物理算法简析</h3><p>针对低性能手机端或者要求低功耗、毛发物理计算的精确度需求非常低的场景，有一种极简廉价的等效替代方案。该方案的毛发物理计算方法既不是基于每一根发丝的，也不是基于每一小缕、每一小撮、每一小束的，而是类似于在这一大把毛发上加上一些骨骼，然后把这一大把毛发等效成一系列刚体球，然后在这些球间添加弹簧质点约束，采用通用物理引擎直接进行计算，计算结果驱动毛发的骨骼动画。这种极简的替代方案，可以将一个角色的披头的长发等效成几个刚体球，如下图所示，计算时实际上只有几个刚体球的计算，开销非常小。弊端也非常明显，只能模拟简单的发型，而且物理模拟效果不理想。</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/20220529140000.png" alt="简单廉价的等效替代方案，红色圆圈为等效的刚体球"></p><p>另一种方案是基于发丝的等效，将发丝等效成一个弹簧质点模型，这种等效方案下的毛发模拟与布料模拟是类似的。一根发丝是一条curve曲线，在曲线上选取一系列的点作为质点，在质点间添加上弹簧约束，如下图所示。与布料模拟不同，布料是面状的结构，其中之一的质点与其周围的质点间都有相互作用，而发丝是线状结构，更容易做并行计算（基于每根发丝）。</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/20220529110119.png" alt="发丝的弹簧质点模型-图源来自miloyip博客"></p><p>但是这种过于简化的弹簧质点模型模拟的毛发会使得发丝像锁链一般，因为该模型的约束只有一个，发丝会像绳子一样过分柔软，而生物的毛发往往具有一定的刚度。MiloYip大佬在《爱丽丝惊魂记：疯狂再临》的爱丽丝头发制作中遇到了同样的问题，于是提出了改进的模型，在该模型中再加入一类约束，在发丝中一个质点的前后两个质点间再加上一个弹簧约束，如下图所示。我们可以参考大佬的文章<a href="https://www.cnblogs.com/miloyip/archive/2011/06/14/alice_madness_returns_hair.html">《爱丽丝的发丝——《爱丽丝惊魂记：疯狂再临》制作点滴》</a>。</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/20220529110231.png" alt="发丝的改进版弹簧质点模型-图源来自miloyip博客"></p><p>这一改进模型解决了发丝过分柔软的问题，但是仍然有弊端，它只能处理披头的头发，发丝不能有弯曲和扭曲，然而众所周知，有的人的头发是自然卷，有的人的头发烫了个大波浪……</p><p>TressFX瞄准了这个方向建立了自己的一套新的改进模型。要模拟带有弯曲和扭曲的塑型头发，可以使用刚性弹簧，但是刚性弹簧目前难用于实时的物理模拟，因为强弹簧力的积分很容易使得质量弹簧阻尼系统不稳定，除非使用复杂的如implicit backward integrator的积分方案，另外，在GPU中同一求解器很难同时处理拉伸、弯曲和扭曲弹簧。基于此，TressFX提出了简化的全局形状约束和局部形状约束来等效。</p><p>TressFX新的改进模型已经相对比较完善了，即使不是物理正确的。但是这个模型还是仍然有些小的弊端，比如没有考虑马尾的处理，真实的一根头发是一条曲线，如果技美在做马尾的建模时，把这根头发的马尾辫和前面的部分分别建模，做成了两根曲线时，这个算法模型就懵逼了，会当成两根头发来处理，就会出现“后地中海式秃”的现象，算法会把前面部分的曲线的尾部当成了发丝尾，但实际上这个尾部有一个发圈的固定约束。另外TressFX的发丝长度约束是一个迭代缩短的过程，如果角色加速度非常大且保持非常大的加速度在变化，长度约束就比较难收敛，就会出现比较明显的头发拉长现象。</p><p>但是我们在看古墓丽影中的劳拉时，会发现她是个马尾，并且拉长现象并不明显，有理由猜测古墓丽影的团队有可能对算法做了更多的优化，另外马尾的建模是一根发丝一体建模的。</p><h3 id="毛发渲染算法简析"><a href="#毛发渲染算法简析" class="headerlink" title="毛发渲染算法简析"></a>毛发渲染算法简析</h3><p>毛发渲染部分，除了光照模型对毛发的效果产生主要的光照效果影响外，发丝的半透明混合和抗锯齿也非常值得关注。</p><p>发丝数量动辄上万根，用传统的针对半透明物体的先排序再按从后往前依次渲染的方法是走不通的，这里的方法基本上是借鉴的OIT的处理思路。</p><p>要实现完全的渲染正确，需要使用PPLL(Per-Pixel Linked Lists)的方法，针对RenderTarget的每个像素维护一个GPU并行链表，链表按深度顺序连接，绘制时根据当前发丝在占据的像素的深度在链表中插入，全部发丝绘制结束后最后一个Pass对每个像素的链表进行颜色混合，这种方法对硬件有要求，且显存的消耗不可控。TressFX的PPLL方案不是一个真正的链表结构，它针对每个像素预开了一定大小的空间用来存储深度和颜色信息（TressFX实现上每个像素能存16组深度和颜色信息，即最大链表节点数为16个，这个空间写死了，可详见代码TressFXPPLL.cpp中的TressFXPPLL::Create函数实现），这种方式不受限于硬件，但是当一个像素上的发丝数量过多时，不够存储的部分会丢弃，而当一个像素上的发丝数量过少时，剩余的空间就浪费了。而TressFX的ShortCut方案是借鉴的PPLL思想简化的处理过程，用一个3Layers的图存储不同深度下的颜色，最终只叠加这三层颜色，这种做法比PPLL占用的内存空间和计算量都更小很多，但是是渲染不完全正确的。另外，Intel曾提出<a href="https://www.intel.com/content/www/us/en/developer/articles/technical/oit-approximation-with-pixel-synchronization.html">Adaptive Transparency的OIT方案</a>，是用来改进PPLL的内存和性能问题的简化方法，它的思想是修改经典的混合公式，引入一个能见度函数（transmittance&#x3D;visible_function(depth)），近似出一个能见度函数后，就可以不再要求链表按深度顺序连接了，但是同样地，渲染也不完全正确了，混合精度也会有所下降，<a href="http://www.klayge.org/2013/02/18/%E7%BB%A7%E7%BB%AD%E6%8E%A2%E7%B4%A2oit%EF%BC%9Aadaptive-transparency/">KlayGE在引擎中实现了该方案</a>可以给我们参考。</p><p>另外，由于发丝非常的细，拓展出来的三角形面片非常的小，很容易出现锯齿和空洞，我们需要对发丝渲染结果做抗锯齿处理和补空洞。抗锯齿用一些常用的抗锯齿方法就可以处理。空洞出现的原因大多是因为毛发过细，三角形面片都不足以达到一个像素的大小，在毛发发丝数量稀疏的地方，就会导致空洞的出现，TressFX会在发丝三角形面片不足一个像素时扩展到一个像素，以缓解空洞的问题。</p><p>发丝的生物结构主要由纤维构成，可以分为中心的发髓（Medulla）、内部的皮质（Cortex）和表皮的角质层（Cuticle），如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/20220529110643.png" alt="发丝的生物结构图"></p><p>电子显微镜下我们还可以看到角质层呈现出倾斜的鳞片状，这是头发造成高光和反射的主要介质。由于角质层的鳞片状具有指向性，由发根指向发尾，如下图所示，这个现象可以用发丝的切线方向和毛发材质的各向异性来描述。</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/20220529110734.png" alt="发丝的角质层电镜图-图源来自网络"></p><p>而毛发一般足够细，厚度非常的薄，光穿过头发还会发生<em>透射</em>和<em>次反射&#x2F;散射</em>。</p><p>毛发光照模型中的Kajiya算法，是一个简单的不符合物理真实的光照模型，但它也足够简单、计算量小。它首先假设了发丝是一个光滑的圆柱体，然后再应用上各项异性（对入射光进行一定角度的偏移）来模拟角质层的鳞片样状带来的影响。Kajiya算法只考虑反射带来的影响，不考虑透射和散射的影响。如下图所示：在计算光的specular分量时，Kajiya算法类似于直接计算镜面反射，但为了加入各项异性的影响，引入了一个小角度的光偏移，该光偏移的角度值是一个正弦函数变化的值，这样我们就能模拟实现头发上的天使环；而在计算光的diffuse分量时，迎着光方向的发丝在0到180度范围内做积分，这样就得到了漫反射值。</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/20220529213928.png" alt="Kajiya光照模型"></p><p>而Marschner算法，是一个基于测量头发光照属性得到相应的测算数据后建立的渲染模型，它将发丝视为半透明圆柱体，然后从物理的角度，将光照分成三条不同的路径：1.R项，代表光在头发表面发生的反射，该项产生毛发主要的高光，呈现出光色，受到毛发的切线和各向异性的影响；2.TRT项，代表光折射进入发丝，反射后再折射出发丝，该项产生次高光，呈现出带有发丝颜色的高光；3.TT项，代表光折射进入发丝，再由发丝的另一侧折射而出，该项产生透射的效果，在光打到毛发上，视角迎着毛发和光方向时，呈现出透光。基于这三条光照路径，将发丝继续分为横截面和纵切面分别进行计算，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/20220529214626.png" alt="Marschner光照模型"></p><p>这里我们仅简单介绍一下概念，在实现时再详细展开。</p><h3 id="已有的商业方案"><a href="#已有的商业方案" class="headerlink" title="已有的商业方案"></a>已有的商业方案</h3><ul><li>UE4(4.26前)：集成了NVIDIA HairWorks；</li><li>UE4(4.26后)与UE5：毛发渲染采用自研的Groom，基于Marschner渲染模型，物理模拟借用的粒子的物理模拟器Niagara；</li><li>O3DE：尝试集成的AMD TressFX，并整合进自己的RenderGraph中，但是没有实现完，发丝的碰撞矫正没有实现，会出现毛发穿模进模型中，渲染仅使用了GGX光照模型；</li><li>网易《逆水寒》：使用的AMD TressFX；</li><li>完美世界《笑傲江湖》：初期集成NVIDIA HairWorks，后转自研；</li><li>腾讯手游《王者荣耀》：妲己的尾巴，基于Unity实现的FurShell（算法简单，叠多层的PBR）；</li><li>《爱丽丝惊魂记：疯狂再临》：MiloYip大大最早在2009年做的头发，基于改良的弹簧质点模型的头发物理模拟和Kajiya光照模型的渲染；</li><li>其他一些国外的游戏公司：《古墓丽影》集成了AMD TressFX、《巫师》集成了NVIDIA HairWorks……</li><li>Frostbite：在SIGGRAPH2019上展示了一段效果很好的头发系统，但是目前仅有视频和PPT，没有项目，没有开源；</li><li>Unity：未开源，无法一窥究竟；但Unity有文章说他们将TressFX集成到URP和HDRP管线中，其中URP管线还实现了在手机侧高通865的芯片上1w根发丝能跑到60帧。</li></ul><h3 id="路该怎么走"><a href="#路该怎么走" class="headerlink" title="路该怎么走"></a>路该怎么走</h3><p>回归到原始的调研目的，目前最快最有希望走通的路是，将NVIDIA HairWorks或AMD TressFX先集成到自己的引擎中，然后吸收消化它们的算法和思想，基于它们的基底再进行“改造升级”。</p><p>讲毛发的文章真的是少之又少，在这些非常稀少的文章中，不少文章讲讲概念，然后分析了毛发的渲染算法，再然后直接上UE引擎上调效果去了，讲具体在引擎中的实现细节的几乎没有，那只好靠自己啦。</p><p>我站在HairWorks和TressFX的岔路口踌躇，比对了一下两者的效果，TressFX实现出来的物理模拟效果更“海飞丝”一些，另外TressFX可供参考的文章和例子（例如O3DE、the-forge等开源引擎都集成过TressFX）更多一些，于是选择了TressFX（现在回过头来看，可能当初选错路了呢，粗看它们Hairworks的工具链更完整一些，HairWorks甚至做了一个完备的HairWorks Viewer，在Viewer里能够预览和简单编辑，可以方便地提供给技美做验证，而TressFX只有一个示例工程，但是既然已经沿着这条路走下去了，只能硬头皮上吧，说不准HairWorks也有其他的问题呢&#x3D;_&#x3D;）。</p><h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><p>本小节往后与接下来的文章将着重分析TressFX的毛发实现，我将以TressFX中的demo程序进行分析。</p><p>在开始之前，强烈建议先读一遍《GPU Pro 5: Advanced Rendering Techniques》中P407-417(TressFX Hair Simulation)&#x2F;P193-209(TressFX Hair Rendering)和<a href="https://zhuanlan.zhihu.com/p/343741493">AMD官方的针对TressFX4.1的讲解文章</a>，虽然官方的这篇文章只是简单谈了一下采用的算法及列了部分的源代码（有些已经对不上开源仓中的代码了，而《GPU Pro 5》则是针对的TressFX的3.x版本的讲解），然后说明了一下各个参数的具体意义，方面使用者调参时参考。但是这也已经是全网少有的毛发讲解文章了。看完再上路，中途不尿裤。</p><blockquote><p>TressFX官方给出的集成方案是让开发者替换实现<code>EI_</code>开头的所有类（EI意为Engine-Interface），但是这种方案其实很hardcode，比如渲染引擎本身有场景类Scene，而TressFX中又有EI_Scene类，两者都要共存，会导致两份场景数据，EI_Scene中需要多存毛发需要的场景信息如灯光信息环境光信息等，否则无法带上光照的效果。另外，直接对接EI相关的类，在集成上虽然是方便了一些，但是往往不符合一个引擎正常的pipeline过程，比如引擎本身有RenderGraph，这样做会导致我们绕开了引擎的RenderGraph系统，直接通过RHI接口进行毛发物理模拟和渲染了，这对引擎的架构和维护都会带来很大的冲击。<br>因此，最佳实践方案应是将TressFX的算法理解吸收，然后遵照引擎的框架重新实现（抄）一遍。这里推荐参考<a href="https://github.com/o3de/o3de">O3DE引擎</a>集成TressFX的方案，截至目前虽然它做的还不算非常的完善，比如基于SDF的碰撞矫正还没有加进来，光照算法也只有一个GGX能完全正常工作，但它的实现思路还是非常值得我们参考和借鉴的。</p></blockquote><h3 id="子功能一览"><a href="#子功能一览" class="headerlink" title="子功能一览"></a>子功能一览</h3><p>我们先简单看看TressFX的头发系统都有哪些子功能。</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/TressFX_Others_HairSystemSubmodules.jpg" alt="毛发系统子功能图"></p><h3 id="RenderPass一览"><a href="#RenderPass一览" class="headerlink" title="RenderPass一览"></a>RenderPass一览</h3><p>然后再从宏观角度来看看TressFX整体的RenderPass图，这张图费了我一点时间才整理出来，图中的所有Passes将对应头发系统中的所有子功能。</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/TressFX_01.png" alt="RenderPass总览图"></p><p>这里我们不要求能够把整张图完全看懂，只需要从感官上有个大体的轮廓，后面将会针对每个Pass逐一展开，进行详细的分析，届时可以再回过头来对照着看。</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/TressFX_02.png" alt="图例及统计信息"></p><p>针对整个场景中只有1个头发模型和1个角色模型&#x2F;头发附着体模型的场景，头发的物理模拟需要9个Passes，渲染根据选择的半透明混合算法的不同，分别需要4个Passes或2个Passes，除此之外，场景中每个灯源产生的阴影要带上头发的影响，还需要独立的Pass给头发做全局阴影。假设一个最简单的头发场景，只有1个灯源且仅往地面这一个面的方向上投射阴影，加上一个简单的ForwardPBR和ToneMapping，一个带头发的最简单的场景至少需要17个Passes(ShortCut)或15个Passes(PPLL)（即：*9(物理模拟) + 4(渲染ShortCut) 或 2(渲染PPLL) + 1(普通模型阴影) + 1(头发模型阴影) + 1(PBR) + 1(ToneMapping)*）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;毛发算法调研分析&quot;&gt;&lt;a href=&quot;#毛发算法调研分析&quot; class=&quot;headerlink&quot; title=&quot;毛发算法调研分析&quot;&gt;&lt;/a&gt;毛发算法调研分析&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;开篇&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该系列的文章主要记录我在研究和实现毛发</summary>
      
    
    
    
    <category term="开发杂记" scheme="https://blog.kdyx.net/categories/%E5%BC%80%E5%8F%91%E6%9D%82%E8%AE%B0/"/>
    
    <category term="CV/CG" scheme="https://blog.kdyx.net/categories/%E5%BC%80%E5%8F%91%E6%9D%82%E8%AE%B0/CV-CG/"/>
    
    
    <category term="Hair" scheme="https://blog.kdyx.net/tags/Hair/"/>
    
    <category term="毛发渲染" scheme="https://blog.kdyx.net/tags/%E6%AF%9B%E5%8F%91%E6%B8%B2%E6%9F%93/"/>
    
    <category term="物理模拟" scheme="https://blog.kdyx.net/tags/%E7%89%A9%E7%90%86%E6%A8%A1%E6%8B%9F/"/>
    
    <category term="数字人" scheme="https://blog.kdyx.net/tags/%E6%95%B0%E5%AD%97%E4%BA%BA/"/>
    
    <category term="发丝" scheme="https://blog.kdyx.net/tags/%E5%8F%91%E4%B8%9D/"/>
    
    <category term="TressFX" scheme="https://blog.kdyx.net/tags/TressFX/"/>
    
  </entry>
  
  <entry>
    <title>忘记MySQL数据库密码解决方案</title>
    <link href="https://blog.kdyx.net/blog/kongdeyou/find_forget_sql_password/"/>
    <id>https://blog.kdyx.net/blog/kongdeyou/find_forget_sql_password/</id>
    <published>2022-03-20T09:45:00.000Z</published>
    <updated>2024-04-04T03:53:39.524Z</updated>
    
    <content type="html"><![CDATA[<p>今天研究图床的时候发现忘记了自己服务器上的MySQL数据库的密码，抓瞎了……研究了一下数据库如何重置密码，特此记录。</p><p>新打开一个terminal，进到MySQL的安装路径的bin下，执行以下指令，跳过权限验证：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --skip-grant-tables</span><br></pre></td></tr></table></figure><p>此时该terminal会卡住，直到我们按下Ctrl+C退出，这段时间里数据库将可以不用密码直接访问（但不可以删数据表中的数据）。</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/find_forget_sql_password_2.png" alt="图1"></p><p>然后再打开一个新的terminal，执行以下指令，以root用户进入MySQL：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root</span><br></pre></td></tr></table></figure><p>进入MySQL后，执行以下指令将root用户的密码更新为指定的新密码（your_new_password）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update user set authentication_string = Password(&#x27;your_new_password&#x27;) where User = &#x27;root&#x27;;</span><br><span class="line">flush privileges;</span><br><span class="line">exit;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/find_forget_sql_password_1.png" alt="图2"></p><p>退出两个控制台，密码就改好了。</p><p>后来…我发现了一个问题，wordpress是需要指定数据库账号和密码的……我完全可以从wordpress的配置文件中找到它……&#x3D;_&#x3D;+</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/find_forget_sql_password_3.png" alt="图3"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天研究图床的时候发现忘记了自己服务器上的MySQL数据库的密码，抓瞎了……研究了一下数据库如何重置密码，特此记录。&lt;/p&gt;
&lt;p&gt;新打开一个terminal，进到MySQL的安装路径的bin下，执行以下指令，跳过权限验证：&lt;/p&gt;
&lt;figure class=&quot;highl</summary>
      
    
    
    
    <category term="工具杂记" scheme="https://blog.kdyx.net/categories/%E5%B7%A5%E5%85%B7%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="MySQL" scheme="https://blog.kdyx.net/tags/MySQL/"/>
    
    <category term="数据库" scheme="https://blog.kdyx.net/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="忘记密码" scheme="https://blog.kdyx.net/tags/%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>超香之PicGo+Github搭建免费图床</title>
    <link href="https://blog.kdyx.net/blog/kongdeyou/make_picture_bed_by_picgo_and_github/"/>
    <id>https://blog.kdyx.net/blog/kongdeyou/make_picture_bed_by_picgo_and_github/</id>
    <published>2022-03-20T08:12:00.000Z</published>
    <updated>2024-04-04T03:53:39.524Z</updated>
    
    <content type="html"><![CDATA[<p>自从Typora开始收费以后，转向使用VSCode配合Office Viewer (Markdown Editor)插件来写博客。每次上传博客时图片也总是个麻烦的问题，得先上传到wordpress的资源中，再编辑图片链接，修改markdown中的链接，这一套下来实在费劲。今天薅个图床来加速这个过程 :-)</p><p>Step1: VSCode安装PicGo插件</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/picture_bed_1.png" alt="图床-图1"></p><p>Step2：Github新建一个公开的图床仓库，并在 Setting -&gt; Developer Setting -&gt; Personal access tokens 中生成一个永久不过期、只拥有repo权限的tokens。</p><p>（这一步网上有很多教程，但我没按通用的教程来配置。我专门新建一个Github用户TiEngineRobot来操作TiEngine&#x2F;PictureBed图床仓库，PictureBed仓赋予TiEngineRobot以Maintainer的权限，这样该用户就可以控制图床仓啦，然后再生成TiEngineRobot的tokens，这样我们就可以不使用我们自己的私有账号来生成tokens，不影响私人账号的使用~）</p><p>Step3：配置VSCode中的PicGo</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/picture_bed_2.png" alt="图床-图2"></p><p>按上图方法进入设置页面，然后按下图方式修改配置，其他的配置项保持不变：</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/picture_bed_3.png" alt="图床-图3"></p><p>简单解释一下各配置项的具体意义：</p><p>branch：分支名，必须是默认分支，这样可以方便后面的cdn加速<br>custom url：免费的CDN加速链接，将其中的TiEngine&#x2F;PictureBed修改为[你的Github账户]&#x2F;[你的图床仓库]即可<br>repo：必须填写[你的Github账户]&#x2F;[你的图床仓库]<br>token：粘贴由第二步生成出来的一串token字符串</p><p>Step4：Okay~复制一个图片，直接在VSCode里Ctrl+Alt+U吧，一键直接享受舒适^.^</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;自从Typora开始收费以后，转向使用VSCode配合Office Viewer (Markdown Editor)插件来写博客。每次上传博客时图片也总是个麻烦的问题，得先上传到wordpress的资源中，再编辑图片链接，修改markdown中的链接，这一套下来实在费劲。今</summary>
      
    
    
    
    <category term="工具杂记" scheme="https://blog.kdyx.net/categories/%E5%B7%A5%E5%85%B7%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="图床" scheme="https://blog.kdyx.net/tags/%E5%9B%BE%E5%BA%8A/"/>
    
    <category term="PicGo" scheme="https://blog.kdyx.net/tags/PicGo/"/>
    
  </entry>
  
  <entry>
    <title>3D渲染中远处物体Z-Fighting(闪烁)问题</title>
    <link href="https://blog.kdyx.net/blog/kongdeyou/3d_rendering_farplane_zfighting/"/>
    <id>https://blog.kdyx.net/blog/kongdeyou/3d_rendering_farplane_zfighting/</id>
    <published>2021-11-28T14:39:00.000Z</published>
    <updated>2024-04-04T03:53:39.524Z</updated>
    
    <content type="html"><![CDATA[<p>测试在测编辑器的时候，干了个很骚的事情，把far plane的值调得非常非常大（near plane没有改变），然后将编辑器摄像头拉近拉远，发现当编辑器摄像头拉的很远的时候，视口中显示的物体就开始闪烁起来了，于是拉我们开发来对问题……于是某位开发的一天就这样口干舌燥地过去了……</p><p>我们先明确这个问题是Z-Fighting问题。</p><p>Z-Fighting就是深度冲突，当两个待渲染物体的三角形网格比较接近，几乎平行排列在一起时会发生深度冲突，其本质是深度缓冲没有足够的精度来决定哪个三角形在前面显示，于是这两个三角形会不断地在切换前后顺序导致闪烁。</p><p>深度冲突不是只在远处的物体间才有，近处的物体们如果平行摆放，三角形平行重合的地方也会产生深度冲突的现象。只是远处物体由于接近远平面，而我们在做归一化深度的时候由于归一化函数是非线性的，在远平面处曲线几乎水平，导致归一化后的深度值非常接近，此时如果用来存深度的深度缓冲的浮点精度不够，两个有前后关系的物体就会被截断成同一个深度值。因此远处物体比近处物体更容易产生深度冲突的现象。尤其是当我们的测试把far plane的值调得非常大，near plane和far plane间距很大的时候（此时在远平面附近的曲线更水平，斜率更小了）。另外我们有时候在游戏中会发现，远处高山上接近消失点地方的一棵树和一栋房子在我们轻微移动人物的视角的时候有可能会在闪，这大概率也是深度冲突的问题。</p><p>我们在将物体渲染到屏幕上时，必不可少地需要经过下面的坐标系变化，以将3D场景中的物体画到2D的显示窗口中：</p><p>物体的局部坐标系 -&gt; 物体的世界坐标系 -&gt; 物体在摄像机视角下的相机坐标系 -&gt; 摄像机底片的投影坐标系 -&gt; 规格化设备坐标(NDC)（归一化的深度值）</p><p>这些坐标变换在顶点着色器阶段(VS)中完成，“物体在摄像机视角下的相机坐标系 -&gt; 摄像机底片的投影坐标系 -&gt; 规格化设备坐标(NDC)（归一化的深度值）”这一步就是MVP矩阵变换中的P矩阵做的事情。</p><p>我们不在此处去推MVP矩阵了，网上随便搜一下都有。直接给出P矩阵的公式（其中：近平面n，远平面f，垂直视场角v，透视纵横比r）：</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/wp-content/uploads/2021/11/pic_farplane_zfighting_1.png" alt="pic_farplane_zfighting_1"></p><p>任何一个物体的一个顶点经过“物体的局部坐标系 -&gt;M-&gt; 物体的世界坐标系 -&gt;V-&gt; 物体在摄像机视角下的相机坐标系”变换后，都会得到该顶点在相机坐标系下的坐标，此时的该坐标中的z是该顶点在相机视角下的深度，该深度不是归一化的，从前面的P矩阵中我们可以得知z的归一化函数g(z)（事实上，这个g(z)是在推导P矩阵的过程中获得的，这里我们只是反过来将它拿出来）：</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/wp-content/uploads/2021/11/pic_farplane_zfighting_2.png" alt="pic_farplane_zfighting_2"></p><p>我们重点来关注这个用来归一化深度的非线性函数g(z)。来点“科学”的分析工具，我写了一段matlab代码来画出near plane、far plane在不同值时的g(z)曲线。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% gen_gz.m</span></span><br><span class="line"></span><br><span class="line">n = [  <span class="number">1</span>,  <span class="number">1</span>,   <span class="number">1</span> ];</span><br><span class="line">f = [ <span class="number">10</span>, <span class="number">20</span>, <span class="number">100</span> ];</span><br><span class="line"></span><br><span class="line">z = <span class="number">0</span>:<span class="number">0.01</span>:<span class="built_in">max</span>(f);</span><br><span class="line"></span><br><span class="line"><span class="comment">% size(..) returns [col, row]</span></span><br><span class="line">size_n = <span class="built_in">size</span>(n); size_f = <span class="built_in">size</span>(f);</span><br><span class="line">group = <span class="built_in">min</span>([size_n(<span class="number">2</span>), size_f(<span class="number">2</span>)]);</span><br><span class="line"></span><br><span class="line">info = cell(<span class="number">1</span>, group);</span><br><span class="line"><span class="keyword">for</span> index = <span class="number">1</span>:group</span><br><span class="line">    crnt_n = n(index);</span><br><span class="line">    crnt_f = f(index);</span><br><span class="line">    temp_a = crnt_f / (crnt_f - crnt_n);</span><br><span class="line">    temp_b = - (crnt_n * crnt_f) ./ ((crnt_f - crnt_n) * z);</span><br><span class="line">    g = temp_a + temp_b;</span><br><span class="line">    <span class="comment">% draw curves in a figure</span></span><br><span class="line">    info&#123;index&#125; = [<span class="string">&#x27;g(z)&#x27;</span>, <span class="string">&#x27;,n=&#x27;</span>, num2str(crnt_n), <span class="string">&#x27;,f=&#x27;</span>, num2str(crnt_f)];</span><br><span class="line">    <span class="built_in">plot</span>(z, g, <span class="string">&#x27;LineWidth&#x27;</span>, <span class="number">1.2</span>);</span><br><span class="line">    <span class="built_in">hold</span> on</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">axis([<span class="number">0</span> <span class="built_in">max</span>(f) <span class="number">0</span> <span class="number">1</span>]);</span><br><span class="line"><span class="built_in">legend</span>(info);</span><br><span class="line">grid on</span><br><span class="line"></span><br><span class="line">clear crnt_n crnt_f temp_a temp_b index g</span><br></pre></td></tr></table></figure><p>运行一下，得到下图：</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/wp-content/uploads/2021/11/pic_farplane_zfighting_3.png" alt="pic_farplane_zfighting_3"></p><p>根据图片我们可以看到，当near plane不变，far plane变大时，靠近远平面的大部分的深度值都被集中映射到了归一化区间中的一段很小的区域内（当n&#x3D;1,f&#x3D;100时，在50到100的相机深度值被映射到了0.98到1.0的范围内，而0到50的相机深度值占据了0.0到0.98范围）。</p><p>当far plane继续变大时，我们再来看看：</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/wp-content/uploads/2021/11/pic_farplane_zfighting_4.png" alt="pic_farplane_zfighting_4"></p><p>阿西吧，都成一个直角了！</p><p>来点狠的，把far plane搞成999999999（别数了，9个9），我们调整一下显示的坐标轴限制在0.99999998到1之间：</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/wp-content/uploads/2021/11/pic_farplane_zfighting_5.png" alt="pic_farplane_zfighting_5"></p><p>为什么选择0.99999998到1之间呢，因为大多数情况下我们会给深度缓冲的格式为<code>FORMAT_D24_UNORM_S8_UINT</code>，深度值用24bits的浮点数来存储，有效位数只达到8位。即0.99999998和0.99999999是两个深度值。而0.999999981、0.999999982、0.999999985…这些个在0.99999998和0.99999999间的值，由于精度不够，都会变成同一个深度值。</p><p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/wp-content/uploads/2021/11/pic_farplane_zfighting_6.png" alt="pic_farplane_zfighting_6"></p><p>反映在图中，就是所有在A深度范围内的物体归一化深度值都是同一个(0.99999998)，而所有在B深度范围内的物体，归一化的深度值也是同一个(0.99999999)。</p><p>于是，当测试把far plane的值调得非常大的时候，再把摄像头拉远，本来有前后关系的物体们由于归一化过程中丢精度了，就被计算机当成平行的物体了，两个物体的三角形网格一重合，这一块渲染出来的画面就开始闪了。</p><p>深度冲突问题目前没有很好的解决方法，基本是根据具体的业务情况选择相应的规避措施，规避的方法主要有：</p><p>使用更高精度的深度缓冲，比如采用FORMAT_D32_FLOAT；</p><p>根据具体的业务场景选择合适的near plane和far plane的值，避免相差过大；</p><p>根据具体的业务场景计算出物体距离摄像机的距离，离摄像机较远的物体避免深度上相距太近。</p><p>终于阐述清楚了。所以，这个问题别再提问题单了啊…w(ﾟДﾟ)w</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;测试在测编辑器的时候，干了个很骚的事情，把far plane的值调得非常非常大（near plane没有改变），然后将编辑器摄像头拉近拉远，发现当编辑器摄像头拉的很远的时候，视口中显示的物体就开始闪烁起来了，于是拉我们开发来对问题……于是某位开发的一天就这样口干舌燥地过去了</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>渲染三大金刚——CommandQueue、CommandList、CommandAllocator之间的关系梳理</title>
    <link href="https://blog.kdyx.net/blog/kongdeyou/commandqueue_commandlist_commandallocator/"/>
    <id>https://blog.kdyx.net/blog/kongdeyou/commandqueue_commandlist_commandallocator/</id>
    <published>2021-11-19T11:27:00.000Z</published>
    <updated>2024-04-04T03:53:39.524Z</updated>
    
    <content type="html"><![CDATA[<p>之前看Vulkan的书，写得云里雾里的，搞到最后只记住了几个API把代码跑起来，好久没用后还忘了，直到最近抽空看DX12的龙书，才彻底把它们的关系给理清楚，特此记录。</p><p>命令队列（CommandQueue）：在GPU中，是一块环形缓冲区，是GPU的命令执行队列，每个GPU至少维护一个CommandQueue。如果该队列为空，GPU将空闲空转，等到有指令过来；如果该队列满了，将阻塞CPU的执行。</p><p>命令列表（CommandList）：在CPU中，用来记录GPU的执行指令，我们期望让GPU执行的任务会通过它来记录。</p><p>命令分配器（CommandAllocator）：在CPU中，用来给CommandList记录的指令分配空间，这个空间用来在CPU侧存储指令，不存储资源。</p><p>提交指令：DX12通过ExecuteCommandLists函数，将CommandList中记录的指令提交给GPU中的CommandQueue。CPU和GPU是两个处理器，它们在两条独立的跑道上并行地跑，CommandQueue就是GPU的跑道。CommandList在调用 设置视口(SetViewPort)、清屏(ClearRenderTarget)、发起绘制(DrawIndex) 这些函数的时候，并没有真正地执行这些操作，只是将这些指令记录下来，直到执行ExecuteCommandLists函数，指令就从CPU送到GPU的CommandQueue中，这个从CPU送GPU过程不一定是立即送的，当然GPU也不是立即调用，而是按CommandQueue中的顺序依次执行指令。</p><p>三大金刚关系：一个GPU至少维护一个CommandQueue。CommandList用于在CPU侧进行指令记录，CommandList可以有多个。创建CommandList要指定分配器CommandAllocator，CommandAllocator也可以有多个，同时一个CommandAllocator可以关联多个CommandList，但是关联同一CommandAllocator的CommandList们不能同时记录指令，因为CommandList记录的指令的内存由CommandAllocator来分配，我们需要保证<code>(((记录的指令)的内存)的连续性)</code>，这样才能一把送到CommandQueue中，并发记录会破坏内存连续性。</p><p>关于重置：CommandQueue在GPU中，是GPU的执行跑道，不能重置。CommandList在记录完指令并提交指令后可以重置（然后可以复用它记录新的指令），因为提交指令后，CommandAllocator还在维护着这块内存。在没有确定GPU执行完CommandAllocator中的指令前不能重置CommandAllocator，因为底下实现可能会起Job一点点地去送指令到GPU，而提交指令的函数操作会立即返回。</p><p>资源和指令不同，资源是执行指令需要的“原料”，即需要加工处理的数据。资源会开在GPU内存中，由对应的资源描述符来引用，资源有Host可见（CPU、GPU均可访问）的和Host不可见（CPU不可访问，只有GPU可访问）的，通过映射GPU内存地址，可以把内存中的资源数据拷贝到Host可见的GPU内存中。</p><p>有一个概念需要明确一下：显卡 ≠ GPU，显卡 &#x3D; GPU + GPU底板 + GPU独立内存。这个和计算机组成中的CPU、主板、内存条是对应的。</p><p>GPU内存分为共享内存和独立内存。独立内存在显卡上，就是常说的显存，共享内存在内存条上。这个共享内存的共享是指和应用程序共享（不是指CPU和GPU共享），其他应用程序也可以用这块内存区域，只是操作系统会优先分给GPU使用。共享内存的大小由操作系统根据内存条的大小、显卡要求等环境参数自动分配，不可更改，独立内存在显卡上，买显卡的时候会标显存大小。Host可见的资源不一定在共享内存中，事实上操作系统会优先使用独立内存（物理上距离GPU也近，传输距离短），但是在加载了大量资源后，独立内存不够存放了，就会使用共享内存。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前看Vulkan的书，写得云里雾里的，搞到最后只记住了几个API把代码跑起来，好久没用后还忘了，直到最近抽空看DX12的龙书，才彻底把它们的关系给理清楚，特此记录。&lt;/p&gt;
&lt;p&gt;命令队列（CommandQueue）：在GPU中，是一块环形缓冲区，是GPU的命令执行队列，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C++并发编程01-管理线程</title>
    <link href="https://blog.kdyx.net/blog/kongdeyou/cpp_concurrency_01/"/>
    <id>https://blog.kdyx.net/blog/kongdeyou/cpp_concurrency_01/</id>
    <published>2021-11-18T16:22:00.000Z</published>
    <updated>2024-04-04T03:53:39.524Z</updated>
    
    <content type="html"><![CDATA[<h2 id="用std-thread简单地创建并启动线程"><a href="#用std-thread简单地创建并启动线程" class="headerlink" title="用std::thread简单地创建并启动线程"></a>用std::thread简单地创建并启动线程</h2><p>简单来说，使用C++线程库启动一个线程，只需要构造一个std::thread对象的实例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采用普通函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoSomeWork</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动一个线程执行DoSomeWork()函数</span></span><br><span class="line"><span class="function">std::thread <span class="title">thread</span><span class="params">(DoSomeWork)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采用仿函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Do some work...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动一个线程执行task()函数</span></span><br><span class="line">Task task;</span><br><span class="line"><span class="function">std::thread <span class="title">thread1</span><span class="params">(task)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造一个Task的临时对象并启动线程执行该临时对象的仿函数</span></span><br><span class="line"><span class="comment">// NB: 注意此处如果使用std::thread thread2(Task())，</span></span><br><span class="line"><span class="comment">//     部分编译器可能会报错，因为C++编译器会将其解析为函数</span></span><br><span class="line"><span class="comment">//     声明，而不是类型对象的定义(C++&#x27;s most vexing parse)。</span></span><br><span class="line"><span class="function">std::thread <span class="title">thread2</span><span class="params">(Task&#123;&#125;)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采用lumbda表达式</span></span><br><span class="line"><span class="function">std::thread <span class="title">thread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">// 启动一个线程执行lumbda表达式内的内容</span></span></span></span><br><span class="line"><span class="params"><span class="function">[]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">// Do some work...</span></span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="join——等待线程汇入"><a href="#join——等待线程汇入" class="headerlink" title="join——等待线程汇入"></a>join——等待线程汇入</h2><p>即等待线程结束。最大粒度的线程间同步，当前线程在此时等待另一线程结束汇入后再往下执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoSomeWork</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 假设当前为主线程，thread线程为该进程内除主线程外唯一的子线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">thread</span><span class="params">(DoSomeWork)</span></span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (thread.<span class="built_in">joinable</span>()) &#123; <span class="comment">// 判断当前thread实例持有线程</span></span><br><span class="line">        thread.<span class="built_in">join</span>(); <span class="comment">// 主线程等待thread线程结束汇入</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>如果不等待线程汇入，就必须要保证当前线程结束后，其他线程不会访问该线程中已经释放的资源（当前线程栈上的对象、当前线程执行的线程函数生命周期结束时栈展开会依次析构的对象等等）。这个问题不是多线程才有的问题，单线程代码中访问一个已经销毁的对象也会导致crash，只是多线程增加了这种问题发生的几率。</p><p>如果std::thread对象的实例持有线程，在析构销毁前既没有join又没有detach，程序就会异常终止（std::thread的析构中会调用std::terminate()）。因此，即使有异常存在，也要保证线程能够正常汇入或分离【参考后文中的“thread_guard——使用RAII来保证线程正常工作”】。</p><h2 id="detach——分离线程-后台执行"><a href="#detach——分离线程-后台执行" class="headerlink" title="detach——分离线程(后台执行)"></a>detach——分离线程(后台执行)</h2><p>线程detach后，线程的归属和控制将由C++运行库接管和处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoSomeWork</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 假设当前为主线程，thread线程为该进程内除主线程外唯一的子线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">thread</span><span class="params">(DoSomeWork)</span></span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (thread.<span class="built_in">joinable</span>()) &#123; <span class="comment">// 判断当前thread实例持有线程</span></span><br><span class="line">        thread.<span class="built_in">detach</span>(); <span class="comment">// 线程分离，当前thread实例不在持有该线程，</span></span><br><span class="line">                         <span class="comment">// 此时thread就可以正常析构了。</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>需要注意的是，线程detach后如果主线程结束（即main函数return后，也即进程结束了）或任意线程调用exit终止了整个进程，该线程也会立即结束。</p><h2 id="与std-thread中的线程传递参数"><a href="#与std-thread中的线程传递参数" class="headerlink" title="与std::thread中的线程传递参数"></a>与std::thread中的线程传递参数</h2><p>往新启动的线程传递参数（即线程函数的参数）只需要将这些参数作为 std::thread构造函数的附加参数即可，类似于std::bind传递参数的过程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoSomeWork</span><span class="params">(<span class="type">int</span> a, <span class="type">double</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动一个线程执行DoSomeWork(int a, double b)函数，并传递参数a=1,b=0.1</span></span><br><span class="line"><span class="function">std::thread <span class="title">thread</span><span class="params">(DoSomeWork, <span class="number">1</span>, <span class="number">0.1</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>需要注意的是，这些参数会<strong>拷贝</strong>至新线程的内存空间中，<strong>即使函数中的参数是引用的形式，拷贝操作也会执行！</strong>这里的引用只能是形如*const [数据类型] &amp;*的常量引用，比如const double&amp;，非常量引用会导致编译出错。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> value = <span class="number">0.1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoSomeWork</span><span class="params">(<span class="type">int</span> a, <span class="type">const</span> <span class="type">double</span>&amp; b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的常量1和变量value的值都会被拷贝一份至新线程的内存空间中，新线程在运行DoSomeWork函数时，b引用的是新线程内存空间中的值！</span></span><br><span class="line"><span class="function">std::thread <span class="title">thread</span><span class="params">(DoSomeWork, <span class="number">1</span>, value)</span></span>;</span><br></pre></td></tr></table></figure><p>我们可以用如下代码验证，打印出来的地址将是不同的两个：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 虽然传的是引用（常量引用），但是是新线程内存空间中的，而不是主线程中的那个value</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoSomeWork</span><span class="params">(<span class="type">int</span> a, <span class="type">const</span> <span class="type">double</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; &amp;b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> value = <span class="number">0.1</span>;</span><br><span class="line">    std::cout &lt;&lt; &amp;value &lt;&lt; std::endl; <span class="comment">// 在主线程的value</span></span><br><span class="line">    <span class="comment">// 传给DoSomeWork的value将是拷贝一份的新线程内存空间中的值</span></span><br><span class="line">    <span class="function">std::thread <span class="title">thread</span><span class="params">(DoSomeWork, <span class="number">1</span>, value)</span></span>;</span><br><span class="line">    thread.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传参过程可能遇到的三种问题：</p><p>(1) 传递的参数是<strong>指向动态变量的指针</strong></p><p>发生问题的地方在于：标准没有给出<em>隐式转换的操作</em>和<em>std::thread构造函数的拷贝操作</em>的顺序的定义，各个编译器的实现可能有差异，有可能std::thread的构造函数拷贝的是转换前的变量，那么这个转换前的变量有可能在拷贝时失效了，如果这个变量是个指针，将会出现问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoSomeWork</span><span class="params">(std::string s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateDoSomeWorkThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">32</span>] = <span class="string">&quot;...&quot;</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">thread</span><span class="params">(DoSomeWork, buffer)</span></span>; <span class="comment">// here!</span></span><br><span class="line">    thread.<span class="built_in">detach</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">CreateDoSomeWorkThread</span>();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码中的“here!”处，我们传递的是buffer数组的指针，有的编译器实现可能在std::thread的构造函数拷贝转换前的变量buffer数组的指针而不是隐式转换后的std::string，当要进行隐式转换的时候，CreateDoSomeWorkThread()函数已经结束，buffer数组的生命周期已经结束，此时再进行隐式转换就会出现问题。</p><p>解决这个问题的方法就是直接显示地转换，这样转换始终会在std::thread构造函数的拷贝操作之前，我们手动确定了顺序。上面的代码可以改成如下安全的形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoSomeWork</span><span class="params">(std::string s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateDoSomeWorkThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">32</span>] = <span class="string">&quot;...&quot;</span>;</span><br><span class="line">    <span class="comment">// buffer → std::string(buffer)：使用std::string进行显式转换，避免野指针</span></span><br><span class="line">    <span class="function">std::thread <span class="title">thread</span><span class="params">(DoSomeWork, std::string(buffer))</span></span>;</span><br><span class="line">    thread.<span class="built_in">detach</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">CreateDoSomeWorkThread</span>();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2) 传递的参数是<strong>非常量引用</strong></p><p>本节的前面提到过“传递的参数会拷贝至新线程的内存空间中，即使函数中的参数是引用的形式，但是不能传非常量引用，否则会报编译错误”：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> value = <span class="number">0.1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoSomeWork</span><span class="params">(<span class="type">int</span> a, <span class="type">double</span>&amp; b)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">thread</span><span class="params">(DoSomeWork, <span class="number">1</span>, value)</span></span>; <span class="comment">// 编译错误！</span></span><br></pre></td></tr></table></figure><p>这是因为DoSomeWork第二个参数期待传入一个引用，但std::thread的构造函数并不知晓，构造函数会无视函数参数类型，盲目地拷贝已提供的变量，但内部代码会将拷贝的参数以右值的方式进行传递，这是为了支持那些仅支持移动不支持拷贝的类型，而后会尝试以右值为实参调用DoSomeWork，但因为函数期望的是一个非常量引用作为参数而非右值，此时就报了编译错误。这个问题和在使用std::bind时不能直接传递非常量引用是同样的问题。因此也有同样的解法，即<em>使用std::ref或std::cref将参数转换成引用的形式，同时需要注意此时参数将不会拷贝至新线程的内存空间中，传递的是引用而非拷贝的副本！！</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoSomeWork</span><span class="params">(<span class="type">int</span> a, <span class="type">double</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; &amp;b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> value = <span class="number">0.1</span>;</span><br><span class="line">    std::cout &lt;&lt; &amp;value &lt;&lt; std::endl; <span class="comment">// 在主线程的value</span></span><br><span class="line">    <span class="comment">// 使用了std::ref传递引用，传给DoSomeWork的value将是主线程value的引用</span></span><br><span class="line">    <span class="function">std::thread <span class="title">thread</span><span class="params">(DoSomeWork, <span class="number">1</span>, std::ref(value))</span></span>;</span><br><span class="line">    thread.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将看到，打印出来的地址是相同的，都是主线程中的value的地址。</p><p>此时我们要注意引用对象（在这里是value）的生命周期问题，下面的这段代码就是有问题的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoSomeWork</span><span class="params">(<span class="type">int</span> a, <span class="type">double</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    std::cout &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::thread thread;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> value = <span class="number">0.1</span>;</span><br><span class="line">        thread = std::<span class="built_in">thread</span>(DoSomeWork, <span class="number">1</span>, std::<span class="built_in">ref</span>(value));</span><br><span class="line">    &#125;</span><br><span class="line">    thread.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>value的生命周期已经结束了，但是运行DoSomeWork的线程还在使用它。但是如果我们运行这段代码，会发现程序没有崩溃，这是因为std::ref或std::cref返回的对象是std::reference_wrapper，而std::reference_wrapper本质存储的是指针！也就是说，我们在运行DoSomeWork的线程里用了一个野指针在操作，只是还没有发生踩内存而已。</p><p>(3) 传递的参数<strong>仅支持移动不支持拷贝</strong></p><p>此时，当传递的实例是临时变量时，则自动进行移动操作，但当原对象是一个命名变量，转移的时候就需要使用std::move()进行显式移动。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoSomeWork</span><span class="params">(std::unique_ptr&lt;<span class="type">int</span>&gt; a)</span></span>;</span><br><span class="line"></span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; p = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(DoSomeWork, std::move(p))</span></span>; <span class="comment">// 命名变量，使用std::move显式移动</span></span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">(DoSomeWork, std::make_unique&lt;<span class="type">int</span>&gt;(<span class="number">2</span>))</span></span>; <span class="comment">// 临时变量，隐式移动</span></span><br></pre></td></tr></table></figure><p>最后，线程函数是可以有返回值的，那么线程结束时也就有返回值，该返回值可以通过std::future获取，这将在第四篇总结文章中详细记录。详见：<a href="https://tis.ac.cn/blog/kongdeyou/cpp_concurrency_04">https://tis.ac.cn/blog/kongdeyou/cpp_concurrency_04</a></p><h2 id="在std-thread间转移线程所有权"><a href="#在std-thread间转移线程所有权" class="headerlink" title="在std::thread间转移线程所有权"></a>在std::thread间转移线程所有权</h2><p>C++标准库中有很多资源占有(resource-owning)类型，如std::ifstream、std::unique_ptr、std::thread都是可移动但不可复制的（即NonCopyable）。</p><p>std::thread只可移动不可复制，我们只可以转移std::thread的所有权，这会导致旧的std::thread实例内的线程被转移到新的std::thread实例内。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoSomeWork</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(DoSomeWork)</span></span>;     <span class="comment">// 创建一个新线程，t1持有该线程所有权</span></span><br><span class="line">std::thread t2 = std::<span class="built_in">move</span>(t1); <span class="comment">// 移动t1给t2，t2持有该线程所有权，t1不再持有线程</span></span><br><span class="line">t1 = std::<span class="built_in">thread</span>(DoSomeWork);   <span class="comment">// 再创建一个新线程（临时的std::thread变量），t1持有该线程所有权（临时变量的赋值操作符，走隐式移动）</span></span><br><span class="line">std::thread t3;                 <span class="comment">// 此时t3不持有任何线程的所有权</span></span><br><span class="line">t3=std::<span class="built_in">move</span>(t2);               <span class="comment">// 移动t2给t3，t3持有该线程所有权，t2不再持有线程</span></span><br><span class="line">t1=std::<span class="built_in">move</span>(t3);               <span class="comment">// 赋值操作将使程序崩溃，因为t1已经持有了线程【参考后文中的“joining_thread——完善地支持移动的情景”】</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">CreateThread1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DoSomeWork</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">thread</span>(DoSomeWork);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">CreateThread2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DoSomeWork</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(DoSomeWork)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器默认启动返回值优化，函数返回时如果返回的是值类型时会走移动构造。另外std::thread是NonCopyable的。</span></span><br><span class="line">std::thread t1 = <span class="built_in">CreateThread1</span>(); <span class="comment">// t1持有CreateThread1中返回的线程，CreateThread1中的临时对象转移给了t1</span></span><br><span class="line">std::thread t2 = <span class="built_in">CreateThread2</span>(); <span class="comment">// t2持有CreateThread2中返回的线程，CreateThread2中的t转移给了t2</span></span><br></pre></td></tr></table></figure><p>扩展：NonCopyable基类可以实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NonCopyable</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">NonCopyable</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">NonCopyable</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">NonCopyable</span>(<span class="type">const</span> NonCopyable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    NonCopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NonCopyable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>某个类如果要实现为NonCopyable的，继承该类即可。</p><h2 id="确定线程的数量"><a href="#确定线程的数量" class="headerlink" title="确定线程的数量"></a>确定线程的数量</h2><p>获取CPU核心数量：<br>unsigned int cores &#x3D; std::thread::hardware_concurrency();<br>获取的该值仅是参考值，一般多核机器返回逻辑核心的数量。当无法获取时，返回0。</p><p>量化分析并合理设置工作线程数：<br>线程在执行的过程中，执行计算时需要占用CPU资源，等待时不会占用CPU资源，我们可以通过量化分析（比如带时间戳打日志进行统计、使用Visual Studio的性能分析工具分析等等），可以计算出工作线程运行过程中这两部分时间的比例（执行计算耗时 : 阻塞等待耗时）。<br>我们为了让CPU完全跑满，那么针对N核机器，通过单线程执行所有任务分析出执行计算的平均耗时为x、平均阻塞等待耗时为y，则工作线程数设置为<code>N(x+y)/x</code>时，能让CPU的利用率最大化。</p><h2 id="线程标识"><a href="#线程标识" class="headerlink" title="线程标识"></a>线程标识</h2><p>线程标识的数据类型：<br>std::thread::id</p><p>获取线程标识：<br>(1) 通过std::thread对象的成员函数get_id()获取，如果std::thread实例没有执行线程，返回std::thread::id的默认构造值；<br>(2) 通过当前线程调用std::this_thread::get_id()获取。</p><p>std::thread::id实例可以自由拷贝和对比（已重载了“&#x3D;&#x3D;”运算符），因为只是一个用于标识某个线程的id值。同时标准库提供了std::hash&lt;std::thread::id&gt;容器，可以作为键值使用。</p><h2 id="thread-guard——使用RAII来保证线程正常工作"><a href="#thread-guard——使用RAII来保证线程正常工作" class="headerlink" title="thread_guard——使用RAII来保证线程正常工作"></a>thread_guard——使用RAII来保证线程正常工作</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">thread_guard</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">thread_guard</span><span class="params">(std::thread&amp; thread)</span> : t(thread) &#123;</span>&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">thread_guard</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (t.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">            t.<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">thread_guard</span>(thread_guard <span class="type">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    thread_guard&amp; <span class="keyword">operator</span>=(thread_guard <span class="type">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::thread&amp; t;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以这样使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoSomeWork</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">thread</span><span class="params">(DoSomeWork)</span></span>;</span><br><span class="line">    <span class="function">thread_guard <span class="title">guard</span><span class="params">(thread)</span></span>;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>thread_guard的线程所有权还是在thread实例，没有传递到thread_guard的实例guard里，thread_guard只是存储了std::thread的引用，这在使用的时候有可能会带来其他的麻烦：比如thread实例被移动走了，开发者期望移动到其他地方保留下来后台运行这个线程，但是thread_guard析构的时候join了，当前线程会强制等待该线程执行结束，这导致了开发不期望的结果。</p><h2 id="scoped-thread——移动线程所有权到scoped-thread中来"><a href="#scoped-thread——移动线程所有权到scoped-thread中来" class="headerlink" title="scoped_thread——移动线程所有权到scoped_thread中来"></a>scoped_thread——移动线程所有权到scoped_thread中来</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">scoped_thread</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">scoped_thread</span><span class="params">(std::thread&amp; thread)</span></span></span><br><span class="line"><span class="function">        : t(std::move(thread)) // 移动线程所有权到scoped_thread内的t</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (!t.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;empty thread&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">scoped_thread</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scoped_thread</span>(scoped_thread <span class="type">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    scoped_thread&amp; <span class="keyword">operator</span>=(scoped_thread <span class="type">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::thread t;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>scoped_thread能不完全解决上述的问题，我们把线程所有权转移到scoped_thread中，这样thread中将不持有任何线程。但是由于没有重载operator&#x3D;&#x3D;实现移动操作，我们还不能直接移动scoped_thread来实现开发者期望的移动到其他地方保留下来后台运行这个线程。这将在joining_thread中完全解决。</p><h2 id="joining-thread——完善地支持移动的情景"><a href="#joining-thread——完善地支持移动的情景" class="headerlink" title="joining_thread——完善地支持移动的情景"></a>joining_thread——完善地支持移动的情景</h2><p>我们在“在std::thread间转移线程所有权”这一节中提到了重复赋值导致程序崩溃的问题，我们在前一节实现的scoped_thread中并没有将该问题解决，这一节中将解决这个问题。</p><p>事实上这也是C++17标准给出的一个建议，但是C++委员会成员没有达成一致，因此joining_thread类没有加入到C++17中，但C++20仍然对此进行了探讨，并实现了一个std::jthread（然鹅仍然还是没有进到标准中::T_T::）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">joining_thread</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">joining_thread</span>() <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func, <span class="keyword">typename</span> ...Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">explicit</span> <span class="title">joining_thread</span><span class="params">(Func&amp;&amp; func, Args&amp;&amp; ...args)</span> :</span></span><br><span class="line"><span class="function">        t(std::forward&lt;Func&gt;(func), std::forward&lt;Args&gt;(args)...) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">joining_thread</span><span class="params">(std::thread thread)</span> <span class="keyword">noexcept</span> :</span></span><br><span class="line"><span class="function">        t(std::move(thread)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">joining_thread</span>(joining_thread&amp;&amp; other) <span class="keyword">noexcept</span> :</span><br><span class="line">        <span class="built_in">t</span>(std::<span class="built_in">move</span>(other.t)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    joining_thread&amp; <span class="keyword">operator</span>=(joining_thread&amp;&amp; other) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当其他joining_thread实例想移动进来，而当前实例内的仍持有线程时</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">            <span class="built_in">join</span>(); <span class="comment">// 会join当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">        t = std::<span class="built_in">move</span>(other.t); <span class="comment">// 再移动进来</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    joining_thread&amp; <span class="keyword">operator</span>=(std::thread other) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当其他joining_thread实例想移动进来，而当前实例内的仍持有线程时</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">            <span class="built_in">join</span>(); <span class="comment">// 会join当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">        t = std::<span class="built_in">move</span>(other); <span class="comment">// 再移动进来</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">joining_thread</span>() <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">            <span class="built_in">join</span>(); <span class="comment">// 析构时保证仍持有线程时一定会走join</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(joining_thread&amp; other)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        t.<span class="built_in">swap</span>(other.t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::<span class="function">thread::id <span class="title">get_id</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">get_id</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">joinable</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">joinable</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">detach</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        t.<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread&amp; <span class="title">as_thread</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> std::thread&amp; <span class="title">as_thread</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::thread t;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后，我们来复盘看看thread_guard、scoped_thread、joining_thread的区别：</p><p>thread_guard只是简单地将一个std::thread的实例包装进来做RAII管理，线程的所有权还在std::thread实例中；</p><p>scoped_thread会将std::thread的实例中的线程移动到scoped_thread的肚子里面来管理，但是scoped_thread不能移动出去，只能在自己生命周期结束时走析构的时候join线程；</p><p>joining_thread实现了完善的线程包装器，用它的构造函数能够创建线程，并且在自己的生命周期结束时，如果线程没有join或detach过，自动地join线程保证正常使用线程，同时实现了移动构造和移动赋值，支持移动操作，当其他joining_thread实例想移动进来，而当前实例内的仍持有线程时，会join当前线程，再移动进来。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;用std-thread简单地创建并启动线程&quot;&gt;&lt;a href=&quot;#用std-thread简单地创建并启动线程&quot; class=&quot;headerlink&quot; title=&quot;用std::thread简单地创建并启动线程&quot;&gt;&lt;/a&gt;用std::thread简单地创建并启动线程</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C++并发编程00-并发世界</title>
    <link href="https://blog.kdyx.net/blog/kongdeyou/cpp_concurrency_00/"/>
    <id>https://blog.kdyx.net/blog/kongdeyou/cpp_concurrency_00/</id>
    <published>2021-11-18T16:11:00.000Z</published>
    <updated>2024-04-04T03:53:39.524Z</updated>
    
    <content type="html"><![CDATA[<h2 id="并发的概念"><a href="#并发的概念" class="headerlink" title="并发的概念"></a>并发的概念</h2><p><strong>并发</strong>：两个或两个以上的独立活动同时发生。</p><p><strong>计算机中的并发</strong>：单个系统里同时执行多个独立的任务。</p><p>并发与并行：<br>“并发”指的是代码的性质，强调任务的抽象调度，反义是“顺序”。因此，单核机器也可以通过分时调度和抢占式多任务来实现并发。<br>“并行”指的是物理运行的状态，强调任务同时执行的真实存在，反义是“串行”。因此，只有多核机器能实现并行。</p><h2 id="并发的方式"><a href="#并发的方式" class="headerlink" title="并发的方式"></a>并发的方式</h2><p><strong>多进程并发</strong></p><p>优点：<br>更容易编写安全的并发代码，单个进程崩溃波及范围有限，有操作系统帮忙兜底。且独立进程方便改造成远程多机间的并发。</p><p>缺点：<br>进程间有内存空间访问壁垒，通讯需要通过进程间通讯的渠道（信号、套接字、管道、文件、全局共享内存等等），进程间通讯复杂，速度慢，大多数时候需要拷贝。另外多进程有固定开销，需要时间给操作系统准备来启动进程，操作系统需要资源来管理进程。</p><p><strong>多线程并发</strong></p><p>优点：<br>所有线程都共享地址空间，并且能访问到大部分数据，全局变量仍然是全局的，指针、对象的引用或数据可以在线程之间快速方便地传递。地址空间共享，以及缺少线程间的数据保护，使得操作系统工作量减小，因此使用多线程的开销远远小于多进程。</p><p>缺点：<br>如果多个线程间需要访问同一地址位置的数据，需要要求开发者来确保每个线程访问到的数据一致且不产生冲突（当然，我们可以参考一些设计方法及引入一些经典库减轻开发者的工作，比如消息队列等等）。</p><h2 id="使用并发的原因"><a href="#使用并发的原因" class="headerlink" title="使用并发的原因"></a>使用并发的原因</h2><p><strong>关注点分离</strong></p><p>使用并发简化成单一关注点，使逻辑更加清晰，任务分离后每个任务职责单一。</p><p><strong>提升性能</strong></p><p>任务并行 (task parallelism)：将一个单任务分成没有互相依赖的多个部分并行运行，从而降低总运行时间。</p><p>数据并行 (data parallelism)：在以相同算法处理一大块数据时，每个线程在不同的小数据块上执行相同的操作。</p><p>阻塞场景性能提升：在阻塞场景下，即使是单核处理器也会有性能的提升。例如起后台线程进行阻塞的I&#x2F;O操作，这样不会阻塞住主进程或UI进程。</p><h2 id="并发虽好，不可滥用"><a href="#并发虽好，不可滥用" class="headerlink" title="并发虽好，不可滥用"></a>并发虽好，不可滥用</h2><p>不使用并发的唯一原因：<strong>收益比不上成本</strong>。</p><p><strong>都有哪些成本？</strong><br>编写和维护成本（设计复杂、难以理解、容易出错、维护困难，人工成本）；<br>固有开销（有限的硬件软件资源：内核资源及堆栈内存空间，一个线程一般至少要消耗1MB的空间，线程上下文切换需要耗时等等）。</p><p>因此，只有性能关键部分，或关注点分离能让设计足够地清晰和便于维护，才值得并发化。</p><h2 id="C-线程库的效率"><a href="#C-线程库的效率" class="headerlink" title="C++线程库的效率"></a>C++线程库的效率</h2><p>C++整合底层工具形成线程库的意义：提升编程效率，与其他语言看齐。</p><p>事实上，写工具库的意义就在于形成高级工具以提升效率。这就需要了解使用高级工具和使用低级工具的<em>开销差</em>，这个开销差就是抽象代价(abstraction penalty)。</p><p>标准库提供了高级别工具，使得编写多线程代码更加简单。因为有额外的代码需要执行，这些工具确实会带来性能开销。总的来说，性能开销和手工编写的函数差不多，并且编译器会内联大部分代码。</p><p>绝大多数情况下，用过高的复杂性和过大的出错率，来交换小幅度的性能收益是不划算的。即便是瓶颈出现在C++标准库的工具中，也可能由低劣的程序设计造成。例如，如果过多的线程竞争一个互斥单元，将会很明显的影响性能。与其在互斥操作上耗费时间死磕去裸写底层代码，不如重新设计，减少互斥单元上的竞争。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;并发的概念&quot;&gt;&lt;a href=&quot;#并发的概念&quot; class=&quot;headerlink&quot; title=&quot;并发的概念&quot;&gt;&lt;/a&gt;并发的概念&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;并发&lt;/strong&gt;：两个或两个以上的独立活动同时发生。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;计算机中的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>转战逼乎声明 :-)</title>
    <link href="https://blog.kdyx.net/blog/kongdeyou/%E8%BD%AC%E6%88%98%E9%80%BC%E4%B9%8E%E5%A3%B0%E6%98%8E/"/>
    <id>https://blog.kdyx.net/blog/kongdeyou/%E8%BD%AC%E6%88%98%E9%80%BC%E4%B9%8E%E5%A3%B0%E6%98%8E/</id>
    <published>2021-11-18T15:26:00.000Z</published>
    <updated>2024-04-04T03:53:39.524Z</updated>
    
    <content type="html"><![CDATA[<p>本来自己搭了个这个小站，记录自己的一些学习历程，另外就是可以当成一个自己和女朋友的知识备份区，好记性不如烂笔头，踩过的坑、学到的东西都能随手记一记。然鹅，小站的运营并不顺利，总有坏人想攻击网站，另外小站的PV数实在是太惨淡了…</p><p>于是我决定转战逼乎了！！</p><p>逼乎的个人主页链接：<a href="https://www.zhihu.com/people/kondeu">https://www.zhihu.com/people/kondeu</a></p><p>但小站仍用来做文章备份，以防哪天知乎不在，曾经写的东西还能有个家。</p><p>以后文章发布平台只有两个，一个知乎，一个我的小破站。没说明均采用CC BY-ND 4.0协议，转载请注明原始出处（小破站的链接）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本来自己搭了个这个小站，记录自己的一些学习历程，另外就是可以当成一个自己和女朋友的知识备份区，好记性不如烂笔头，踩过的坑、学到的东西都能随手记一记。然鹅，小站的运营并不顺利，总有坏人想攻击网站，另外小站的PV数实在是太惨淡了…&lt;/p&gt;
&lt;p&gt;于是我决定转战逼乎了！！&lt;/p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>为什么std::lock能避免死锁</title>
    <link href="https://blog.kdyx.net/blog/kongdeyou/why_lock_avoids_deadlock/"/>
    <id>https://blog.kdyx.net/blog/kongdeyou/why_lock_avoids_deadlock/</id>
    <published>2021-09-15T14:35:00.000Z</published>
    <updated>2024-04-04T03:53:39.524Z</updated>
    
    <content type="html"><![CDATA[<p>最近在研读《C++ Concurrency in Action - 2rd》，在讲到死锁的问题描述和解决方案时，给出了std::lock能够实现同时锁住多个mutex而不出现死锁，但是没有讲为啥用std::lock就能避免死锁。google搜了一下全网也没有人回答这个问题，于是打算翻下STL代码自己看看，参考的VS2019 MSVC 14.29.30037 &lt;mutex>文件的代码。</p><p>先来看一下std::lock函数，std::lock函数能接收多个（至少需要两个，_Lock0和_Lock1是必须的参数）互斥量，而且允许不同类型的互斥量（每个都是独立的互斥量模板，只要实现了lock、unlock、try_lock函数的类都能当做这里的互斥量，用户可以自定义互斥量类型）。std::lock函数调的内部的_Lock_nonmember1函数。</p><pre><code class="language-cpp">template &lt;class _Lock0, class _Lock1, class... _LockN&gt;void lock(_Lock0&amp; _Lk0, _Lock1&amp; _Lk1, _LockN&amp;... _LkN) &#123; // lock multiple locks, without deadlock    _Lock_nonmember1(_Lk0, _Lk1, _LkN...);&#125;</code></pre><p>接下来看下_Lock_nonmember1函数，这个模板函数有一个<i>针对两个以上互斥量的泛化实现</i>，并实现了一个<i>针对两个互斥量的偏特化</i>。两个以上互斥量的泛化实现和针对两个互斥量的偏特化实现，从原理上看是完全一致的。因此我们在这里用针对两个互斥量的偏特化实现来研究“为什么std::lock能避免死锁”这个问题，聚焦问题的本身。</p><p>_Lock_nonmember1函数内循环执行两个_Lock_attempt_small函数，_Lk0和_Lk1两个互斥量在这两个函数中交换了顺序，可以知道只要有一个_Lock_attempt_small函数返回false时就会退出循环，即加锁成功了。</p><pre><code class="language-cpp">template &lt;class _Lock0, class _Lock1&gt;void _Lock_nonmember1(_Lock0&amp; _Lk0, _Lock1&amp; _Lk1) &#123;    // lock 2 locks, without deadlock, special case for better codegen and reduced metaprogramming for common case    while (_Lock_attempt_small(_Lk0, _Lk1) &amp;&amp; _Lock_attempt_small(_Lk1, _Lk0)) &#123; // keep trying    &#125;&#125;</code></pre><p>再进去看_Lock_attempt_small的实现。_Lock_attempt_small先对入参中的_Lk0加锁[1]，然后对_Lk1尝试加锁[2]：如果try_lock返回true说明_Lk1也加锁成功，_Lock_attempt_small返回false让_Lock_nonmember1的while循环退出，_Lk0和_Lk1都成功锁住，std::lock执行结束；如果出现异常会对_Lk0解锁并将异常往上抛出[3]，这一步异常保护是保证了异常安全的，因为异常处理中恢复了之前_Lk0没加锁的状态；如果try_lock返回false说明尝试对_Lk1加锁失败，其他线程占有着_Lk1，此时会对之前已经上锁的_Lk0解锁[4]，然后让渡当前的CPU时间片给其他线程，最后返回true，_Lock_nonmember1的while循环继续。</p><pre><code class="language-cpp">template &lt;class _Lock0, class _Lock1&gt;bool _Lock_attempt_small(_Lock0&amp; _Lk0, _Lock1&amp; _Lk1) &#123;    // attempt to lock 2 locks, by first locking _Lk0, and then trying to lock _Lk1 returns whether to try again    _Lk0.lock(); // [1]    _TRY_BEGIN    if (_Lk1.try_lock()) &#123; // [2]        return false;    &#125;    _CATCH_ALL    _Lk0.unlock(); // [3]    _RERAISE;    _CATCH_END<pre><code>_Lk0.unlock(); // [4]_STD this_thread::yield();return true;</code></pre><p>}</code></pre></p><p>我们再回到_Lock_nonmember1(_Lock0&amp; _Lk0, _Lock1&amp; _Lk1)函数中去看（此时下文中描述的_Lk0和_Lk1是基于_Lock_nonmember1的_Lk0和_Lk1，不是_Lock_attempt_small内的_Lk0和_Lk1），_Lock_nonmember1在调用_Lock_attempt_small时是交替地给进去_Lk0和_Lk1的，即这次先lock住_Lk0再对_Lk1做try_lock，下一次则会交换，先lock住_Lk1再对_Lk0做try_lock，同时当lock住一个锁而try_lock另一个锁失败的时候，会解掉已经lock住的锁，让渡时间片后再重新进入下一次lock和try_lock。这样，使用std::lock的开发者就不必自己去确保两个互斥量始终以相同的顺序去上锁（事实上有些情况下开发者也没法保证，比如开发者在实现一个线程安全的容器的swap函数的时候），而lock住一个锁并try_lock另一个锁失败时解锁并让渡的操作保证了std::lock不会有死锁风险。</p><p>搞懂两个互斥量时std::lock的实现了，扩展一下，再来看看两个以上互斥量时_Lock_nonmember1的实现：</p><pre><code class="language-cpp">// FUNCTION TEMPLATE locktemplate &lt;class _Lock0, class _Lock1, class _Lock2, class... _LockN&gt;void _Lock_nonmember1(_Lock0&amp; _Lk0, _Lock1&amp; _Lk1, _Lock2&amp; _Lk2, _LockN&amp;... _LkN) &#123;    // lock 3 or more locks, without deadlock    int _Hard_lock = 0;    while (_Hard_lock != -1) &#123;        _Hard_lock = _Lock_attempt(_Hard_lock, _Lk0, _Lk1, _Lk2, _LkN...);    &#125;&#125;<p>template &lt;class… _LockN&gt;<br>int _Lock_attempt(const int _Hard_lock, _LockN&amp;… _LkN) &#123;<br>    &#x2F;&#x2F; attempt to lock 3 or more locks, starting by locking _LkN[_Hard_lock] and trying to lock the rest<br>    using _Indices &#x3D; index_sequence_for&lt;_LockN…&gt;;<br>    _Lock_from_locks(_Hard_lock, _Indices&#123;&#125;, _LkN…);<br>    int _Failed        &#x3D; -1;<br>    int _Backout_start &#x3D; _Hard_lock; &#x2F;&#x2F; that is, unlock _Hard_lock</p><pre><code>_TRY_BEGIN_Failed = _Try_lock_range(0, _Hard_lock, _LkN...);if (_Failed == -1) &#123;    _Backout_start = 0; // that is, unlock [0, _Hard_lock] if the next throws    _Failed        = _Try_lock_range(_Hard_lock + 1, sizeof...(_LockN), _LkN...);    if (_Failed == -1) &#123; // we got all the locks        return -1;    &#125;&#125;_CATCH_ALL_Unlock_locks(_Backout_start, _Hard_lock + 1, _Indices&#123;&#125;, _LkN...);_RERAISE;_CATCH_END// we didn&amp;#039;t get all the locks, backout_Unlock_locks(_Backout_start, _Hard_lock + 1, _Indices&#123;&#125;, _LkN...);_STD this_thread::yield();return _Failed;</code></pre><p>}</code></pre></p><p>实现上其实还是类似的，_Lock_attempt_small变成了_Lock_attempt，而_Lock_attempt函数实际上也是先将_Hard_lock锁住（_Lock_from_locks），然后依次对其他的互斥量做try_lock操作（_Try_lock_range），如果所有的锁都锁定了，_Lock_attempt返回-1结束掉_Lock_nonmember1里的while循环，如果失败了，所有已加的锁全部解掉，然后让渡时间片，_Failed是当前的失败位置，返回回去给_Hard_lock，下一次循环时会在这个位置开始lock，再依次try_lock其他的锁。如果出现异常，处理的方式也是类似的，先解掉所有已经加了锁的互斥量上的锁，再往上throw出去。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在研读《C++ Concurrency in Action - 2rd》，在讲到死锁的问题描述和解决方案时，给出了std::lock能够实现同时锁住多个mutex而不出现死锁，但是没有讲为啥用std::lock就能避免死锁。google搜了一下全网也没有人回答这个问题，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>实现一个C++的static_warning</title>
    <link href="https://blog.kdyx.net/blog/kongdeyou/static_warning_in_cpp/"/>
    <id>https://blog.kdyx.net/blog/kongdeyou/static_warning_in_cpp/</id>
    <published>2021-09-01T15:35:00.000Z</published>
    <updated>2024-04-04T03:53:39.524Z</updated>
    
    <content type="html"><![CDATA[<p>C++11标准之后里有<code>static_assert</code>关键字可以做编译期静态断言，可以用来手动扔出一个编译错误，这在写模板、各种底层库的时候可以非常方便地做各种校验，提前把开发的错误用法扼杀住。但是C++标准并没有提供一个能手动扔出编译告警的方法，最近我在写一个库的时候，正好有这么一个需求，想在断言失败的情况下提醒使用该库的开发者（具体是想断言<em><code>atomic&lt;特定的数据类型&gt;</code></em>是否为lock-free的，如果不为lock-free的，提醒使用库的开发者可能会有性能问题），这种warning不影响最终的构建生成，但是需要达到提醒使用者的目的，而且最好是static_warning（编译期的），不要影响最终的产物的执行效率。</p><p>于是，我翻遍了google，发现在stackoverflow上也有人提出了类似的问题，也在回答中找到了一个比较靠谱的方法。稍微小改了一下拿来用了。</p><p>Talk is cheap, show the code：</p><pre><code class="language-cpp">#if defined(__GNUC__)#define DEPRECATE(function, message) function __attribute__((deprecated(message)))#elif defined(_MSC_VER)#define DEPRECATE(function, message) __declspec(deprecated(message)) function#else#define DEPRECATE(function, message)#endif<p>#define MACRO_CATI(l, r) MACRO_CATR(l, r)<br>#define MACRO_CATR(l, r) l##r</p><p>namespace static_warning_space<br>&#123;<br>    struct pass_type &#123;&#125;;<br>    struct warn_type &#123;&#125;;</p><pre><code>template &amp;lt;bool condition&amp;gt;struct converter : public pass_type &#123;&#125;;template &amp;lt;&amp;gt;struct converter&amp;lt;false&amp;gt; : public warn_type &#123;&#125;;</code></pre><p>}</p><p>#define STATIC_WARNING(condition, message)                                   <br>struct MACRO_CATI(static_warning_, <strong>LINE</strong>) {                               <br>    MACRO_CATI(static_warning_, <strong>LINE</strong>)()                                  <br>    {                                                                        <br>        _(::static_warning_space::converter&lt;(condition)&gt;());                 <br>    }                                                                        <br>    DEPRECATE(void _(::static_warning_space::warn_type const&amp;), message) {}; <br>    void _(::static_warning_space::pass_type const&amp;) {};                     <br>}</p><p>#define static_warning STATIC_WARNING</code></pre></p><hr /><p>下面分段来解析一下实现原理。</p><p>C++没有手动触发编译告警的方式，我们得绕个圈来实现，这里是借用了deprecated，将函数声明为弃用，如果使用了弃用的函数，这将触发编译器扔出一个使用已废弃的函数的告警。而事实上，我们会在使用时在message中给出手动扔出告警的真正原因。</p><pre><code class="language-cpp">#if defined(__GNUC__)#define DEPRECATE(function, message) function __attribute__((deprecated(message)))#elif defined(_MSC_VER)#define DEPRECATE(function, message) __declspec(deprecated(message)) function#else#define DEPRECATE(function, message)#endif</code></pre><p>接着往下，这一行的宏用于l和r的拼接，但是为啥定义了两层呢？我也很好奇为啥stackoverflow上这么搞了两层，于是我尝试把它弄成一层，直接使用<code>#define MACRO_CATI(l, r) l##r</code>，发现下文中的__LINE__居然不会被替换成相应的行数了，我去？最后还是没有弄明白是什么原因，等以后搞清楚了再来填坑吧。</p><pre><code class="language-cpp">#define MACRO_CATI(l, r) MACRO_CATR(l, r)#define MACRO_CATR(l, r) l##r</code></pre><p>后面的是关键内容了，定义一个converter模板结构体并特化false的场景，接着定义static_warning宏为一个结构体，在这个结构体的构造函数里根据condition调用对应的名为<code>_</code>（下划线）的函数。而false的场景里的<code>_</code>函数被指定为DEPRECATE，当condition为false时，构造函数里要执行的即是一个deprecated函数，这就迫使编译器报出warning，message里填上触发static_warning的真实原因，让编译器显示出来。</p><pre><code class="language-cpp">namespace static_warning_space&#123;    struct pass_type &#123;&#125;;    struct warn_type &#123;&#125;;<pre><code>template &amp;lt;bool condition&amp;gt;struct converter : public pass_type &#123;&#125;;template &amp;lt;&amp;gt;struct converter&amp;lt;false&amp;gt; : public warn_type &#123;&#125;;</code></pre><p>}</p><p>#define STATIC_WARNING(condition, message)                                   <br>struct MACRO_CATI(static_warning_, <strong>LINE</strong>) {                               <br>    MACRO_CATI(static_warning_, <strong>LINE</strong>)()                                  <br>    {                                                                        <br>        _(::static_warning_space::converter&lt;(condition)&gt;());                 <br>    }                                                                        <br>    DEPRECATE(void _(::static_warning_space::warn_type const&amp;), message) {}; <br>    void _(::static_warning_space::pass_type const&amp;) {};                     <br>}</p><p>#define static_warning STATIC_WARNING</code></pre></p><p>使用上，直接用static_warning宏即可。</p><pre><code class="language-cpp">int main()&#123;    // ...    static_warning(false, &quot;Warning in main&quot;);    // ...&#125;</code></pre><p>验证结果，发现g++、clang都正常报warning了，vs居然报了error？！</p><pre><code class="language-text">1&gt;------ 已启动全部重新生成: 项目: Test, 配置: Debug Win32 ------1&gt;test.cpp1&gt;d:\test\test.cpp(10): error C4996: &#039;main::static_warning_10::_&#039;: Warning in main1&gt;d:\test\test.cpp(10): note: 参见“main::static_warning_10::_”的声明1&gt;已完成生成项目“Test.vcxproj”的操作 - 失败。========== 生成: 成功 0 个，失败 1 个，最新 0 个，跳过 0 个 ==========</code></pre><p>原因是这样的，在vs的msvc中，deprecated对应的是编译规则C4996，对于vs2017及以上的版本，msvc编译工具将这条规则视为了“错误”。但是这个“错误”并不会影响最终构建出产物，只是这条规则的告警等级变严格了（类比一下-Werror下的把警告视为错误），因此我们手动改一下这条编译规则的告警等级，编译选项中附加上<code>/w14996</code>，该编译选项让4996编译规则的警告等级为1，即当项目工程的警告等级等于或大于/W1时，会产生该规则的告警，默认的vs工程（包括cmake生成的）的警告等级/W3，这样就能显示出该warning又构建成功了。【PS: 秉承着挖到底的精神，/w[x]4996，[x]可以取值1~4，[x]为0时该编译选项不存在。】</p><pre><code class="language-text">1&gt;------ 已启动全部重新生成: 项目: Test, 配置: Debug Win32 ------1&gt;test.cpp1&gt;d:\test\test.cpp(10): warning C4996: &#039;main::static_warning_10::_&#039;: Warning in main1&gt;d:\test\test.cpp(10): note: 参见“main::static_warning_10::_”的声明1&gt;Test.vcxproj -&gt; D:\Test\Debug\Test.exe1&gt;已完成生成项目“Test.vcxproj”的操作。========== 全部重新生成: 成功 1 个，失败 0 个，跳过 0 个 ==========</code></pre><p>另外，对于在模板中使用static_warning会有问题，由于模板会在编译期去分析开发者是否在代码中实例化模板对应的类/结构体/函数，因此static_warning直接放在类/结构体中将不会报出任何的warning，因为编译器发现没有使用到它们，于是它们压根就不会参与到最后的编译过程，而对于模板函数中的static_warning，msvc也只能报出最后一种实例化情形下的编译告警。这个问题目前还没有好的解决方案。</p><p>该问题的示例：</p><pre><code class="language-cpp">// static_warning用于模板中template &lt;typename&gt;class TestClass &#123;public:    static_warning(false, &quot;Warning in template&quot;);<pre><code>void func()&#123;    static_warning(false, &amp;quot;Warning in template(func)&amp;quot;);&#125;</code></pre><p>};</p><p>int main()<br>{<br>    TestClass&lt;int&gt; testClassInt;<br>    TestClass&lt;long&gt; testClassLong;<br>    &#x2F;&#x2F; 如果没有以下这两处调用，&quot;Warning in template(func)&quot;也不会显示，模板中没有调用的使用的地方会被编译器识别并不将它们参与编译<br>    testClassInt.func();<br>    testClassLong.func();<br>}</code></pre></p><p>编译输出：</p><pre><code class="language-text">1&gt;------ 已启动生成: 项目: LauncherTest, 配置: Debug Win32 ------1&gt;test.cpp1&gt;d:\test\test.cpp(12): warning C4996: &#039;TestClass&lt;long&gt;::func::static_warning_12::_&#039;: Warning in template1&gt;d:\test\test.cpp(12): note: 参见“TestClass&lt;long&gt;::func::static_warning_12::_”的声明1&gt;d:\test\test.cpp(11): note: 编译 类 模板 成员函数 &quot;void TestClass&lt;long&gt;::func(void)&quot; 时1&gt;d:\test\test.cpp(39): note: 参见对正在编译的函数 模板 实例化“void TestClass&lt;long&gt;::func(void)”的引用1&gt;d:\test\test.cpp(36): note: 参见对正在编译的 类 模板 实例化 &quot;TestClass&lt;long&gt;&quot; 的引用1&gt;Test.vcxproj -&gt; D:\Test\Debug\LauncherTest.exe1&gt;已完成生成项目“Test.vcxproj”的操作。========== 生成: 成功 1 个，失败 0 个，最新 0 个，跳过 0 个 ==========</code></pre><p>只报出了最后实例化的<code>TestClass&lt;long&gt;</code>，而<code>TestClass&lt;int&gt;</code>没有报出warning。</p><hr /><p>参考：</p><p>stackoverflow上别人提出的类似问题：<a href="https://stackoverflow.com/questions/8936063/does-there-exist-a-static-warning">https://stackoverflow.com/questions/8936063/does-there-exist-a-static-warning</a></p><p>vs开发者论坛中别人提出的C4996在vs2017之后被编译器视为error的问题及相应的解决方案：<a href="https://developercommunity.visualstudio.com/t/c4996-shown-as-error-by-default/164550">https://developercommunity.visualstudio.com/t/c4996-shown-as-error-by-default/164550</a></p><p>附录A：</p><p>boost库在1.40之前也提供过static_warning，实现思路也是类似的，但是在1.40及之后版本中就不再有这个文件了，可以参考学习：<a href="https://www.boost.org/doc/libs/1_39_0/boost/static_warning.hpp">https://www.boost.org/doc/libs/1_39_0/boost/static_warning.hpp</a></p><p>附录B：</p><p>我们在前面在定义DEPRECATE宏的时候，判断了__GNUC__编译器默认自带的宏，这个宏并不专门表示gcc或g++，所有支持GNU-C扩展的编译器都对这个宏进行定义，包括clang和ICC，参见：<a href="https://stackoverflow.com/questions/38499462/how-to-tell-clang-to-stop-pretending-to-be-other-compilers">https://stackoverflow.com/questions/38499462/how-to-tell-clang-to-stop-pretending-to-be-other-compilers</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;C++11标准之后里有&lt;code&gt;static_assert&lt;/code&gt;关键字可以做编译期静态断言，可以用来手动扔出一个编译错误，这在写模板、各种底层库的时候可以非常方便地做各种校验，提前把开发的错误用法扼杀住。但是C++标准并没有提供一个能手动扔出编译告警的方法，最近我</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>QNX交叉编译CUnit+CTest</title>
    <link href="https://blog.kdyx.net/blog/yexin/cross_compile_cunit_and_ctest_on_qnx/"/>
    <id>https://blog.kdyx.net/blog/yexin/cross_compile_cunit_and_ctest_on_qnx/</id>
    <published>2021-08-25T12:14:00.000Z</published>
    <updated>2024-04-04T03:53:39.524Z</updated>
    
    <content type="html"><![CDATA[<h1>编译环境</h1><p>host主机：Ubuntu 20.04<br>交叉编译器：qnx710工具链</p><h1>交叉编译器qcc(QNX)编译CUnit源码</h1><h2>下载CUnit源码</h2><p><u><a href="https://sourceforge.net/projects/cunit/">官方网址</a></u>下载源码包，下载得到CUnit-2.1-3.tar.bz2。</p><h2>解压源码包</h2><p>输入命令<code>$ tar -jxvf CUnit-2.1-3.tar.bz2</code>解压，得到CUnit-2.1-3文件夹。</p><h2>修改代码，注释#include &lt;stdlib.h></h2><p>用vscode打开CUnit-2.1-3文件夹，将所有的<code>#include &lt;stdlib.h&gt;</code>替换为<code>/*#include &lt;stdlib.h&gt;*/</code>，注意需要使用C的注释风格，<strong>不能使用&#x2F;&#x2F;</strong>。该头文件包含会导致编译失败，但是发现注释掉了依旧能够编译通过，因此判断注释掉应该是不影响使用的。</p><h2>配置编译工具链环境</h2><p>输入命令<code>$ source /home/autotest/qnx710/qnxsdp-env.sh</code>，将编译工具链配置到环境变量中。</p><h2>编译安装</h2><p>打开终端，进入CUnit-2.1-3，执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">autoscan</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> configure.in configure.ac</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">aclocal</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">autoheader</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">libtoolize</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">automake --add-missing</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">autoconf</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./configure CC=<span class="string">&quot;qcc&quot;</span> CFLAGS=<span class="string">&quot;-Vgcc_ntox86_64&quot;</span> --host=x86_64-linux-gnu –prefix /home/autotest/Desktop/cunit-qnx/install</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make install</span></span><br></pre></td></tr></table></figure><p>安装成功后在&#x2F;home&#x2F;autotest&#x2F;Desktop&#x2F;cunit-qnx&#x2F;install下有对应的安装文件。</p><h1>CMake的编译构建</h1><p>QNX环境：qnx7.1.0</p><p>目的：<strong>编译cmake构建工具是为了在qnx下使用ctest</strong>。</p><p>在编译整个cmake之前，我也考虑过cmake是否支持只对其中的部分功能进行构建，比如只构建一个ctest，或许可以从option中指定，但是经查看没有对应的option可以指定。然后再考虑只对ctest那部分的CMakelists.txt进行构建，发现也是走不通的。</p><p>于是就只能编译整个cmake了。</p><p>我下载的是最新版本的cmake源码，版本号是3.21.1。</p><p>解压cmake源码。大致浏览cmake的cmakelists.txt，可以看到里面是有对QNX的支持的。</p><p>最终的cmake设置都写在qnx.cmake中了。该文件是纯手写的。。qnx.cmake如下：</p><pre><code class="language-cmake  line-numbers">set(QNX_HOST /home/autotest/qnx710/host/linux/x86_64)set(CMAKE_SYSTEM_NAME QNX)set(arch gcc_ntox86_64)set(ntoarch x86_64)set(QNX_PROCESSOR x86_64)set(CMAKE_C_COMPILER $&#123;QNX_HOST&#125;/usr/bin/qcc)set(CMAKE_C_COMPILER_TARGET $&#123;arch&#125;)set(CMAKE_CXX_COMPILER $&#123;QNX_HOST&#125;/usr/bin/q++)set(CMAKE_CXX_COMPILER_TARGET $&#123;arch&#125;)set(CMAKE_ASM_COMPILER qcc -V$&#123;arch&#125;)set(CMAKE_ASM_DEFINE_FLAG "-Wa,--defsym,")set(CMAKE_RANLIB $&#123;QNX_HOST&#125;/usr/bin/nto$&#123;ntoarch&#125;-ranlib    CACHE PATH "QNX ranlib Program" FORCE)set(CMAKE_AR $&#123;QNX_HOST&#125;/usr/bin/nto$&#123;ntoarch&#125;-ar    CACHE PATH "QNX ar Program" FORCE)set(CMAKE_LINKER $&#123;QNX_HOST&#125;/usr/bin/nto$&#123;ntoarch&#125;-ld    CACHE PATH "QNX ld Program" FORCE)add_definitions(-D_XOPEN_SOURCE=700)</code></pre><p>最重要的就是在最后一句<code>add_definitions(-D_XOPEN_SOURCE=700)</code>，这句话的作用我个人理解是自动去找7.0.0版本以上的qnx所需要的库和头文件。</p><p>最后执行build.sh就可以编译安装整个cmake项目了。build.sh如下：</p><pre><code class="language-sh  line-numbers">#!/bin/bashset -eTOP_PATH=$(cd "$(dirname "$0")"; pwd)BUILD_JOBS=$(($(grep -c ^processor /proc/cpuinfo) - 1))echo BUILD_JOBS = $&#123;BUILD_JOBS&#125;source /home/autotest/qnx710/qnxsdp-env.shif test -d installthenrm -rf installfimkdir installmkdir -p buildcd buildcmake ../cmake-3.21.1 -DCMAKE_TOOLCHAIN_FILE=$&#123;TOP_PATH&#125;/qnx.cmake -DCMAKE_INSTALL_PREFIX=$&#123;TOP_PATH&#125;/installmake -j$&#123;BUILD_JOBS&#125;make installcd ..</code></pre><p>cmake源代码文件、qnx.cmake和build.sh都在同一路径下，.&#x2F;build.sh后会在当前路径下创建build文件夹，build文件夹内存放所有的构建产物。install下存放安装的文件。</p><p>最终在qnx上使用ctest时，可以将整个install拷贝到qnx目录下。避免拷贝单个ctest，因为这有可能会导致ctest的功能不全。</p><p>将install通过scp拷贝到qnx下，然后执行<code>$your_path/ctest -h</code>可以看到ctest在qnx上成功运行了。</p><h2>CUnit的编译构建，安装</h2><p>目的：<strong>编译cunit库是为了ctest能够链接</strong>。</p><p>CUnit的具体的编译安装可以查看上面。这个具体说一下遇到的问题和解决方法。</p><h3>问题描述</h3><p>一开始我选择把qcc构建出来的cunit安装到&#x2F;usr下，然后ctest会从系统中找cunit的库以及头文件。但这样会造成对原有系统的破坏，原有系统是Ubuntu的，可是却安装了qcc编译的cunit，在本机上无法使用。</p><h3>解决方法</h3><p>现在已经有解决办法了，能够不破坏原来的系统环境，只给需要的变量赋值，就能够让ctest找到cunit的库以及头文件。</p><p>首先，为了避免破坏原有系统的环境，在安装的时候选择安装在本地目录下。如果configure时已经制定了–prefix，那么还可以在<code>make install</code>的时候<strong>重写一下安装路径</strong>。<code>make install DESTDIR=/home/autotest/Desktop/cunit-ins/install</code>可以对安装路径进行重写，然后CUnit就会安装在&#x2F;home&#x2F;autotest&#x2F;Desktop&#x2F;cunit-ins&#x2F;install&#x2F;usr&#x2F;local下。<em>（我也不知道为啥多了usr&#x2F;local这个路径，不过没关系，成功安装在自己的install路径下就ok）</em>。之后测试项目想要使用cunit的时候，<strong>只需要在CMakeLists.txt的include(CTest)和include(CUnit)之前，指定CUNIT_LIBRARY和CUNIT_INCLUDE_DIR即可</strong>。</p><pre><code class="language-cmake  line-numbers">#设置libcunit.so的具体路径set(CUNIT_LIBRARY /home/autotest/Desktop/cunit-ins/install/usr/local/lib/libcunit.so)  #设置CUnit头文件路径set(CUNIT_INCLUDE_DIR /home/autotest/Desktop/cunit-ins/install/usr/local/include)</code></pre><p><strong>PS.</strong> 在这里插一嘴，export环境变量INCLUDE_PATH和LIBRARY_PATH都不行。只能手动指定CUNIT_LIBRARY和CUNIT_INCLUDE_DIR。</p><h1>测试项目的编译构建</h1><p>现在ctest和cunit都已经准备好了，原有的使用ctest编写的测试代码准备编译并运行。</p><p>需要在原有的测试项目中添加上述所说的CUNIT_LIBRARY和CUNIT_INCLUDE_DIR，<strong>同时可能还需要将cunit的头文件手动包含进去</strong>（include_directory()）。否则可能会报错：找不到&lt;CUnit&#x2F;CUnit.h&gt;。其他地方维持原样即可。</p><p>测试项目遵循cmake规范，可以直接使用上面的cmake编译构建的qnx.cmake和build.sh进行编译构建，这样就省事多了。</p><p>到时候直接把开发那边提供的库和头文件手动包含进去，就可以进行测试了。</p><h2>测试程序的运行</h2><p>测试程序编译好后，准备拷贝到qnx上运行。测试用例的运行需要ctest（启动器）、libcunit.so.1（用于运行时链接），还有就是测试程序。但是有个坑导致了无法使用ctest启动测试程序。</p><h4>坑点1：ctest运行测试用例时要求可执行程序的绝对路径和编译时的保持一致</h4><p>在Ubuntu上编译时，测试程序生成在&#x2F;home&#x2F;autotest&#x2F;Desktop&#x2F;test&#x2F;build下，那么在其他平台上运行时要求也是同样的路径，否则执行ctest时会报错：No test were found!!!。查看了<code>ctest -h</code>没有发现能否设置相对路径，因此目前此坑还没有找到解决方法，只能保持运行平台和编译平台的相对路径一致。</p><p>但是qnx只允许用户在指定的目录下（&#x2F;data）进行mkdir操作，因此无法在qnx上新建一个&#x2F;home目录。于是考虑在编译平台Ubuntu上创建一个和qnx下运行路径一致的目录，于是在ubuntu上<code>sudo mkdir /data/home/test</code>，因此执行build.sh时也只能以<code>sudo</code>执行。于是遇到了坑点2。</p><h5>优雅的解决——待研究</h5><p>似乎有一个优雅的解决办法，具体可以查看<a href="https://stackoverflow.com/questions/43981966/cmake-how-to-specify-directory-where-ctest-should-look-for-executables">问答</a>，正确使用add_test()函数应该可以做到。</p><h4>坑点2：qnx710装在了autotest用户下，导致其他用户无法使用</h4><p>sudo是以管理员用户执行，但是qnx710安装在了autotest下，导致了license与autotest用户绑定，其他用户包括管理员用户无法使用。所以在编译平台Ubuntu上创建一个和qnx下运行路径一致的目录这条路暂时阻塞，需要管理员用户安装qnx710才可以继续进行。</p><p>那只能考虑不用ctest拉起测试程序。单独执行测试程序发现也是可以行得通的，<code>./test -h</code>可以得到一个简单的使用：</p><pre><code class="language-text  line-numbers">-j              junit format results-r FILENAME     result file for automated run -s PATTERN      run only tests in suite matching pattern-t PATTERN      run only test matching pattern</code></pre><p>比如：.&#x2F;test -s “basic”，那么就会运行basic测试套件的所有用例，.&#x2F;test -s “basic” -t “test”，就只会运行CU_Test(basic,test)这个测试用例。</p><h5>解决方法</h5><p>已经有了解决方法：将&#x2F;data&#x2F;路径设置为能够被autotest用户所访问。</p><pre><code class="language-sh  line-numbers">$ chown -hR autotest:autotest /data/</code></pre><p>但是在运行测试程序时，因为测试程序运行时需要动态链接libcunit.so.1，于是我遇到了坑点3。</p><h4>坑点3：qnx下无法将库拷贝到/usr/lib下，且默认不会从当前路径查找库文件</h4><p>我将libcunit.so.1拷贝到测试程序同路径下，再次运行测试程序，发现还是无法load library libcunit.so.1，于是考虑将libcunit.so.1拷贝到&#x2F;usr&#x2F;lib下。但是qnx做了保护，无法将文件拷贝至&#x2F;usr&#x2F;lib下。</p><p>那就只能从环境变量下手了，追加链接库路径的环境变量。</p><pre><code class="language-sh  line-numbers">$ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/data/home/yxtest</code></pre><p>记得要写绝对路径。</p><p>使用ctest执行测试用例时，需要：</p><pre><code class="language-sh  line-numbers">$ export LD_PRELOAD=/data/home/yxtest/libcunit.so.1$ ./ctest --output-on-failure</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;编译环境&lt;/h1&gt;

&lt;p&gt;host主机：Ubuntu 20.04&lt;br&gt;交叉编译器：qnx710工具链&lt;/p&gt;
&lt;h1&gt;交叉编译器qcc(QNX)编译CUnit源码&lt;/h1&gt;

&lt;h2&gt;下载CUnit源码&lt;/h2&gt;

&lt;p&gt;&lt;u&gt;&lt;a href=&quot;https://sou</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>一个倾注灵魂的U盘小偷</title>
    <link href="https://blog.kdyx.net/blog/kongdeyou/auto_disk_copier/"/>
    <id>https://blog.kdyx.net/blog/kongdeyou/auto_disk_copier/</id>
    <published>2021-08-21T09:28:00.000Z</published>
    <updated>2024-04-04T03:53:39.524Z</updated>
    
    <content type="html"><![CDATA[<p>上周末在家整理家里的硬盘，看到了好多以前的照片，感叹时间过得可真快，曾经还是个懵懂少年，如今却快成油腻大叔了（苦涩）。翻看大学的项目文件时，看到了这个AutoDiskCopier，突然间仿佛就回到了高二时抱着《Windows程序设计》在宿舍里啃书的场景，当时书还没完全看完，又正值差不多要会考的时候，政史老师为了大家上课认真听他讲课，从来都不把课件留给我们，于是一个大胆的想法就出现了，第一版应用就是在这样的情形下写出来的，然而当时并没有看到这本书的后面章节，所有的应用上的控件全是一个一个窗口创建并自己维护的…之后看到了书的后面几章，才发现自己实在是太愚蠢了，居然写了个硬核代码出来。虽然第一版就这样了，但是这件事也影响了我后来的思考方式，做一个项目不会马上直接上手写代码，应该先做调研，看看有没有什么更快捷更妙的方法，再关注一下类似的东西都是怎么做的，最后设计和分析，才上手编码。后来大学时有一门程序设计课，结课需要交一个大作业，正好想起了这个项目，借机重构出了第二版，当成大作业交了上去，后来还成了满分项目::(A_A)::。第三版是这一周有空的晚上花上大约半个小时做的，其实代码沿用了第二版的代码，只做了UI的改版和一些问题的修复。</p><p>代码开源在了Github上：<a href="https://github.com/KondeU/AutoDiskCopier">https://github.com/KondeU/AutoDiskCopier</a></p><p>U盘小偷的“偷文件”的技术核心其实很简单，处理Win32的<code>WM_DEVICECHANGE</code>消息就可以了，当有外部设备插入时，Windows会向当前所有进程广播WM_DEVICECHANGE消息。我们在收到该消息后，确认插入的是一个磁盘设备，就可以进行拷贝操作。</p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/wp-content/uploads/2021/08/pic_adc_1.png" alt="pic_adc_1" /><p>为了避免拷贝阻塞消息处理的循环，我们不能直接在主消息循环线程中拷贝，因此我们开个后台线程处理拷贝任务。</p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/wp-content/uploads/2021/08/pic_adc_2.png" alt="pic_adc_2" /><p>其他的外围：<code>通用对话框</code>、<code>系统托盘图标</code>、<code>MD5校验</code>被我封装到了<code>CmnDlg.h</code>、<code>NotifyIcon.h</code>、<code>MD5.h</code>三个文件中，这些通用的模块可以复用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上周末在家整理家里的硬盘，看到了好多以前的照片，感叹时间过得可真快，曾经还是个懵懂少年，如今却快成油腻大叔了（苦涩）。翻看大学的项目文件时，看到了这个AutoDiskCopier，突然间仿佛就回到了高二时抱着《Windows程序设计》在宿舍里啃书的场景，当时书还没完全看完，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>解决vscode和git国内下载速度太慢</title>
    <link href="https://blog.kdyx.net/blog/kongdeyou/speed_up_the_download_of_vscode_and_git/"/>
    <id>https://blog.kdyx.net/blog/kongdeyou/speed_up_the_download_of_vscode_and_git/</id>
    <published>2021-08-10T04:58:00.000Z</published>
    <updated>2024-04-04T03:53:39.524Z</updated>
    
    <content type="html"><![CDATA[<h2>vscode</h2><p>vscode官网下载链接（速度只有25k&#x2F;s左右）：<a href="https://code.visualstudio.com/#alt-downloads">https://code.visualstudio.com/#alt-downloads</a></p><p>点击下载后拿到下载的链接，如：<br><a href="https://az764295.vo.msecnd.net/stable/379476f0e13988d90fab105c5c19e7abc8b1dea8/VSCode-win32-x64-1.59.0.zip">https://az764295.vo.msecnd.net/stable/379476f0e13988d90fab105c5c19e7abc8b1dea8/VSCode-win32-x64-1.59.0.zip</a></p><p>将前面的<code>az764295.vo.msecnd.net</code>换成国内的CDN代理<code>vscode.cdn.azure.cn</code>，直接起飞：<br><a href="https://vscode.cdn.azure.cn/stable/379476f0e13988d90fab105c5c19e7abc8b1dea8/VSCode-win32-x64-1.59.0.zip">https://vscode.cdn.azure.cn/stable/379476f0e13988d90fab105c5c19e7abc8b1dea8/VSCode-win32-x64-1.59.0.zip</a></p><p>vscode默认安装好后是英文界面，在左边栏中找到扩展，搜索Chinese(Simplified)安装中文语言包后就有中文界面了。</p><h2>git</h2><p>git官网的下载链接（速度只有50k&#x2F;s左右）：<a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a></p><p>taobao的镜像源：<a href="https://npm.taobao.org/mirrors/git-for-windows/">https://npm.taobao.org/mirrors/git-for-windows/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2&gt;vscode&lt;/h2&gt;

&lt;p&gt;vscode官网下载链接（速度只有25k&amp;#x2F;s左右）：&lt;a href=&quot;https://code.visualstudio.com/#alt-downloads&quot;&gt;https://code.visualstudio.com/#alt</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Windows开发机装机利器安利存档（持续更新）</title>
    <link href="https://blog.kdyx.net/blog/kongdeyou/windows_essentials_software_recommendations_for_developers/"/>
    <id>https://blog.kdyx.net/blog/kongdeyou/windows_essentials_software_recommendations_for_developers/</id>
    <published>2021-07-29T15:29:00.000Z</published>
    <updated>2024-04-04T03:53:39.524Z</updated>
    
    <content type="html"><![CDATA[<p><strong>个人推荐的Windows开发机装机利器</strong></p><p>持续更新，有好用的立即存档分享，按通用性及使用率大致排了个序。</p><hr /><h3>压缩解压工具：7Zip</h3><p>开源、免费，界面和易用性上虽然赶不上WinRAR，但免费无广告呀，而且使用多线程压缩解压，速度比WinRAR快。<br><a href="https://www.7-zip.org/">https://www.7-zip.org/</a></p><hr /><h3>图片浏览器：XnView</h3><p>免费无广告，XnView支持非常多的图片格式，甚至可以安装编解码器浏览RAW图片，支持简单的编辑。XnView是稳定版，XnViewMP是重构版，相比稳定版增加了支持跨平台和支持Unicode字符，全新的UI界面。<br><a href="https://www.xnview.com/en/">https://www.xnview.com/en/</a></p><hr /><h3>视频播放器：PotPlayer</h3><p>免费无广告，支持非常多的视频格式，可安装扩展编解码库，播放器内功能齐全，快播倒下后的继任者。<br><a href="https://potplayer.daum.net/?lang=zh_CN">https://potplayer.daum.net/?lang=zh_CN</a></p><hr /><h3>文件搜索工具：Everything</h3><p>免费无广告的文件搜索工具，比Windows的搜索快N倍且支持如正则匹配等多种高级搜索功能。<br><a href="https://www.voidtools.com/zh-cn/">https://www.voidtools.com/zh-cn/</a></p><hr /><h3>密码管理工具：KeePassXC</h3><p>开源免费密码管理工具，原版为KeePass，KeePassXC使用Qt5构建，支持跨平台。KeePassXC能加密保存密码到kdbx数据库中，可以联合浏览器自动填充密码。<br><a href="https://github.com/keepassxreboot/keepassxc">https://github.com/keepassxreboot/keepassxc</a></p><hr /><h3>截图工具：Snipaste</h3><p>功能非常强大的截图工具，目前没有发现有超越它的，个人使用免费无广告，商用或组织使用需要购买。<br><a href="https://zh.snipaste.com/">https://zh.snipaste.com/</a></p><hr /><h3>文件资源管理器：Q-Dir (The Quad-Directory-Explorer)</h3><p>免费无广告的文件资源管理器，虽然有点丑但是十分实用。单窗口内多个子窗口显示多个文件夹，同时支持不同标签栏显示不同文件夹，文件夹操作只需要一个进程就足够了，方便多文件夹同时打开，不需要打开一大堆的文件夹窗口还找不到对应的窗口。<br><a href="http://www.softwareok.com/?seite=Freeware/Q-Dir">http://www.softwareok.com/?seite=Freeware/Q-Dir</a></p><hr /><h3>文件资源管理器Tab化插件：三叶草</h3><p>免费国产软件，会侵入式修改系统的Explorer，给Explorer加一层壳，类似谷歌浏览器的标签栏效果，界面效果比Q-Dir好看，但Q-Dir不会侵入式地修改操作系统，个人洁癖所以优先推荐Q-Dir。<br><a href="http://cn.ejie.me/">http://cn.ejie.me/</a></p><hr /><h3>开发环境：Visual Studio</h3><p>若需要其他开发环境推荐：开源免费跨平台的Qt、收费跨平台的JetBrains家的CLion，但还是优先推荐VS，宇宙第一IDE可是yyds。<br><a href="https://visualstudio.microsoft.com/zh-hans/">https://visualstudio.microsoft.com/zh-hans/</a></p><hr /><h3>项目构建：CMake</h3><p>项目构建管理的大一统，能生成各种工程文件，如Visual Studio的.sln、makefile文件等，借用一句名言：CMake is CMake, others are bullshit.<br>下载链接：<a href="https://cmake.org/download/">https://cmake.org/download/</a></p><hr /><h3>代码版本管理：Git</h3><p>多人协作开发必备工具之一。<br><a href="https://git-scm.com/">https://git-scm.com/</a></p><hr /><h3>GitGUI操作工具：TortoiseGit</h3><p>俗称小乌龟，更好地操作git仓，不多介绍了。<br><a href="https://tortoisegit.org/">https://tortoisegit.org/</a></p><hr /><h3>命令行工具：tabby</h3><p>前身是Terminus，支持多标签打开多个不同属性的命令行（PowerShell、PS、CMD、Git-Bash、COM串口、SSH连接）并统一窗口风格，收纳到一个窗口中，开源免费，背景有半透明高斯模糊的毛玻璃效果，还有动画效果，影响性能，直接关掉吧。<br><a href="https://github.com/Eugeny/tabby">https://github.com/Eugeny/tabby</a></p><hr /><h3>画图工具：drawio(https://app.diagrams.net/)</h3><p>支持在线画图，也有Desktop版，开发的各种流程图、时序图、UML图等等都能carry，可以参见之前写的一篇文章<a href="https://tis.ac.cn/blog/kongdeyou/new_experience_of_drawing_with_drawio/">https://tis.ac.cn/blog/kongdeyou/new_experience_of_drawing_with_drawio&#x2F;</a>。<br>在线版：<a href="https://app.diagrams.net/">https://app.diagrams.net/</a><br>桌面版：<a href="https://github.com/jgraph/drawio-desktop/">https://github.com/jgraph/drawio-desktop/</a></p><hr /><h3>邮件收发：Outlook</h3><p>微软自带的就能满足基本的要求了（Win10是有自带的邮箱软件的噢^-^）。</p><hr /><h4>Windows官方效率工具合集PowerToys（目前仍属于PREVIEW，记录于2021年7月28日）</h4><p><a href="https://github.com/microsoft/PowerToys">https://github.com/microsoft/PowerToys</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;个人推荐的Windows开发机装机利器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;持续更新，有好用的立即存档分享，按通用性及使用率大致排了个序。&lt;/p&gt;
&lt;hr /&gt;

&lt;h3&gt;压缩解压工具：7Zip&lt;/h3&gt;

&lt;p&gt;开源、免费，界面和易用性上虽然赶不上WinRAR</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>我撸了一个函数执行包装器后发现……</title>
    <link href="https://blog.kdyx.net/blog/kongdeyou/action_executor/"/>
    <id>https://blog.kdyx.net/blog/kongdeyou/action_executor/</id>
    <published>2021-07-25T15:55:00.000Z</published>
    <updated>2024-04-04T03:53:39.524Z</updated>
    
    <content type="html"><![CDATA[<p>什么？函数包装器？那不是std::function么！好吧，今天提的这个“函数执行包装器”不是简单的std::function，但是和std::function也有很大关系，会用到它的能力。</p><p>事情是这样的，最近在写一个分布式通讯组件，组件会起后台线程异步接收RPC调用请求，然后在每帧同步地调用所请求的函数。本来后台线程只承担数据接收，每帧同步的时候对接收的数据做反序列化，获取出要调用的函数和函数实参，再调用相应的函数，实现RPC。然而，在实际的一个大系统中，主线程每帧的逻辑任务量往往很大，而后台接收线程相对空闲，于是我打算让后台线程多干点活，在后台线程接收到数据后就做好找函数和反序列化函数参数的工作，然后打包到函数执行包装器中，主线程在每帧同步的时候只把函数执行包装器组同步过来，逐一运行即可，不需要再占用主线程来做反序列化和找函数的工作。</p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/wp-content/uploads/2021/08/pic_action_executor.png" alt="pic_action_executor" /><p>要完成上述的任务，我们得需要一个通用的函数执行包装器，通用的意思是能用vector之类的容器存储下来的。单纯的std::function做不到这一点，因为每个函数的参数列表不一致，特例化出来的std::function是不同类型的。除此之外我们还需要把执行函数用到的参数先缓存进我们的包装器里，等到实际运行的时候再使用它们。</p><p>通用的函数执行包装器，本来我的想法是再包装一层std::function&lt;void()&gt;，把接收到的数据反序列化后，映射到对应函数，然后把对应函数的执行过程封装到void()的lambda表达式里，对应的反序列化出来的参数，通过移动捕获的方式传递到lambda表达式中，这样这些参数就变成了自由变量，所有权转移到lambda表达式里。</p><p>后来想到了一个更简单、逻辑更清晰一些的方法。</p><p>首先先做一个ActionExecutor基类，这个基类的Execute函数将承载着在主线程中同步执行函数的任务，主线程不需要关心里面执行的是什么函数，它只需要同步执行函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ActionExecutor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Execute</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Action类是一个模板类，用来保存将要执行的函数和参数，继承Execute并在Execute中实现调用保存下来的函数，传递缓存在类中的参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ...Args&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Action</span> : <span class="keyword">public</span> ActionExecutor &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ArgsTuple = std::tuple&lt;Args...&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Func&gt;</span><br><span class="line">    <span class="built_in">Action</span>(Func&amp;&amp; func, ArgsTuple&amp;&amp; args)</span><br><span class="line">        : <span class="built_in">func</span>(std::forward&lt;Func&gt;(func))</span><br><span class="line">        , <span class="built_in">args</span>(std::forward&lt;ArgsTuple&gt;(args))</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Func&gt;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Action</span><span class="params">(Func&amp;&amp; func, Args&amp;&amp; ...args)</span></span></span><br><span class="line"><span class="function">        : func(std::forward&lt;Func&gt;(func))</span></span><br><span class="line"><span class="function">        , args(std::forward&lt;Args&gt;(args)...)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Execute</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">Invoke</span>(func, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Func&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Invoke</span><span class="params">(Func&amp; func, ArgsTuple&amp; argsTuple)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">constexpr</span> <span class="keyword">auto</span> Size = std::tuple_size&lt;</span><br><span class="line">            <span class="keyword">typename</span> std::decay&lt;ArgsTuple&gt;::type&gt;::value;</span><br><span class="line">        <span class="built_in">InvokeImpl</span>(func, argsTuple, std::make_index_sequence&lt;Size&gt;&#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Func, std::<span class="type">size_t</span> ...Index&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">InvokeImpl</span><span class="params">(Func&amp; func, ArgsTuple&amp; argsTuple,</span></span></span><br><span class="line"><span class="params"><span class="function">        std::index_sequence&lt;Index...&gt;)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        (<span class="type">void</span>)argsTuple; <span class="comment">// Avoid the compilation warning</span></span><br><span class="line">        <span class="comment">// that `the variable has been defined but not used`</span></span><br><span class="line">        <span class="comment">// if the number of parameters of the function is 0.</span></span><br><span class="line">        <span class="built_in">func</span>(std::<span class="built_in">get</span>&lt;Index&gt;(argsTuple)...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::function&lt;<span class="type">void</span>(Args...)&gt; func;</span><br><span class="line">    std::tuple&lt;Args...&gt; args; <span class="comment">// ArgsTuple</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后，我们做一个帮助函数来帮助我们更好地生成一个Action。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MakeAction --&gt; ActionExecutor*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Func, <span class="keyword">typename</span> ...Args&gt;</span><br><span class="line"><span class="function">ActionExecutor* <span class="title">MakeAction</span><span class="params">(Func&amp;&amp; func, std::tuple&lt;Args...&gt;&amp;&amp; args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Action</span>&lt;Args...&gt;(</span><br><span class="line">        std::forward&lt;Func&gt;(func),</span><br><span class="line">        std::forward&lt;std::tuple&lt;Args...&gt;&gt;(args));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Func, <span class="keyword">typename</span> ...Args&gt;</span><br><span class="line"><span class="function">ActionExecutor* <span class="title">MakeAction</span><span class="params">(Func&amp;&amp; func, Args&amp;&amp; ...args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Action</span>&lt;Args...&gt;(</span><br><span class="line">        std::forward&lt;Func&gt;(func),</span><br><span class="line">        std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，就可以愉快地使用函数执行包装器啦（注意实参的所有权问题，一般如果参数是引用，需要std::move转移所有权，否则有可能会出现引用的对象生命周期结束已经被释放的问题，具体使用场景具体分析）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mutex;</span><br><span class="line">std::vector&lt;std::unique_ptr&lt;ActionExecutor&gt;&gt; actions;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    actions.<span class="built_in">emplace_back</span>(std::<span class="built_in">make_unique</span>(<span class="built_in">MakeAction</span>(函数名, 实参)));</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; action : actions) &#123;</span><br><span class="line">        action-&gt;<span class="built_in">Execute</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>等等…我究竟干了啥……突然发现我好像实现了一遍std::bind做的事情，std::bind就能完成我们想要的东西呀！</p><p>来看看std::bind干了啥，<del>和MakeAction简直雷同</del>（MakeAction和它简直雷同）。</p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/wp-content/uploads/2021/07/pic_action_executor_1.png" alt="pic_action_executor_1" /><p>std::bind后会返回一个&#95;Binder，我们看看&#95;Binder的实现。&#95;Binder中用&#95;Mypair来存储要执行的函数和实参，构造函数中转发到&#95;Mypair中储存起来，我们的Action和它也几乎一致。</p><img src="https://cdn.jsdelivr.net/gh/TiEngine/PictureBed@latest/kongdeyou/wp-content/uploads/2021/07/pic_action_executor_2.png" alt="pic_action_executor_2" /><p>嗐，为啥不用标准库中现成的std::bind呢，改一改（同在Action的实现时所说的一样，我们还是要注意实参的所有权问题）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mutex;</span><br><span class="line">std::vector&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; actions;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    actions.<span class="built_in">emplace_back</span>(std::<span class="built_in">bind</span>(&amp;函数名, 类实例（如果是类函数）, 实参));</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; action : actions) &#123;</span><br><span class="line">        <span class="built_in">action</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>也算是实现了一遍标准库的bind和Binder了，摔桌子 (｀□′)╯┴┴</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;什么？函数包装器？那不是std::function么！好吧，今天提的这个“函数执行包装器”不是简单的std::function，但是和std::function也有很大关系，会用到它的能力。&lt;/p&gt;
&lt;p&gt;事情是这样的，最近在写一个分布式通讯组件，组件会起后台线程异步接收R</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>实现一个head-only库中能用的singleton和静态成员变量模板</title>
    <link href="https://blog.kdyx.net/blog/kongdeyou/head_only_singleton_implementation/"/>
    <id>https://blog.kdyx.net/blog/kongdeyou/head_only_singleton_implementation/</id>
    <published>2021-07-23T13:57:00.000Z</published>
    <updated>2024-04-04T03:53:39.524Z</updated>
    
    <content type="html"><![CDATA[<p>一般我们要把一个类写成单例类时，会在类中定义一个static的自己，并将构造函数（甚至析构函数）的访问权限设置为非public，然后提供一个类似GetReference的接口将唯一实例获取出来使用：</p><pre><code class="language-cpp">// Sgt.h<p>#pragma once</p><p>class Sgt &#123;<br>public:<br>    static Sgt&amp; GetReference()<br>    &#123;<br>        return instance;<br>    &#125;</p><p>protected:<br>    Sgt() &#x3D; default;<br>    virtual ~Sgt() &#x3D; default;</p><p>private:<br>    static Sgt instance;<br>&#125;;</code></pre></p><pre><code class="language-cpp">// Main.cppSgt Sgt::instance;int main()&#123;    auto&amp; sgt = Sgt::GetReference();&#125;</code></pre><p>这种方法需要一个cpp去承载类内的静态成员变量的定义，在编译的时候才能正确生成instance的变量实例，否则会报“无法解析的外部命令”的错误（这个定义又不能放到头文件中，否则多个cpp包含该头文件后会出现重复定义），这对于我们打算写一个head-only的库并在库中使用单例模式或是类中打算有静态成员变量来说是十分不友好的。</p><p>C++17通过引入<code>Inline Variable（内联变量）</code>的方式来提供这种支持，我们可以直接在类中声明并定义静态成员变量，这样不需要再找一个cpp文件来放静态成员变量的定义。C++14上还不支持这个功能，但是看到了<u><a href="https://www.boost.org/doc/libs/1_76_0/boost/serialization/singleton.hpp">boost的singleton源码实现</a></u>后，发现了模板的一个妙用，可以实现近乎类似的效果，在此记录分享一下~</p><pre><code class="language-cpp">// Singleton.hpp (Author: Deyou Kong, Date: 2021-06-25, MIT License)<p>#pragma once</p><p>&#x2F;&#x2F; Singleton base class, allow to use C++ CRTP.<br>template &lt;typename T, int N &#x3D; 0&gt;<br>&#x2F;&#x2F; Allows to specify the value of N to achieve<br>&#x2F;&#x2F; a special scenario that there are different<br>&#x2F;&#x2F; instances of the same type, breaking the<br>&#x2F;&#x2F; singleton limit.<br>class Singleton &#123;<br>public:<br>    static T&amp; GetReference()<br>    &#123;<br>        static T instance&#123;&#125;;<br>        return instance;<br>    &#125;</p><pre><code>T&amp;amp; operator()() const&#123;    return reference;&#125;</code></pre><p>private:<br>    static T&amp; reference;<br>};</p><p>&#x2F;&#x2F; If there is a class B that inherits class A,<br>&#x2F;&#x2F; and class A inherits from Singleton&lt;A&gt;, and<br>&#x2F;&#x2F; then an instance of B is created, then there<br>&#x2F;&#x2F; will be two instances of A, one for Singleton&lt;A&gt;<br>&#x2F;&#x2F; created in Singleton&lt;A&gt;::GetReference(), and<br>&#x2F;&#x2F; one is in the B instance. So the singleton<br>&#x2F;&#x2F; class is Singleton&lt;A&gt;, not A.<br>template &lt;typename T, int N&gt;<br>T&amp; Singleton&lt;T, N&gt;::reference &#x3D; Singleton&lt;T, N&gt;::GetReference();</code></pre></p><p>这个Singleton采用C++的奇异递归模板模式(CRTP, Curiously Recurring Template Pattern)，假设类C期望实现为一个单例类，一般写成下面的形式。</p><pre><code class="language-cpp">class C : public Singleton&lt;A&gt; &#123;    ...&#125;;</code></pre><p>假设想在类D中加一个内联静态变量，可以写成下面的形式。Singleton支持指定一个唯一的ID值用来做不同实例的标识，这样在D类中就能有两个int类型的内联静态变量。</p><pre><code class="language-cpp">class D &#123;    ...    Singleton&lt;int, 1&gt; inlineStaticValue1;    Singleton&lt;int, 2&gt; inlineStaticValue2;&#125;;</code></pre><p>enjoy~ 模板的妙用让head-only更简单~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一般我们要把一个类写成单例类时，会在类中定义一个static的自己，并将构造函数（甚至析构函数）的访问权限设置为非public，然后提供一个类似GetReference的接口将唯一实例获取出来使用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CryEngine、Lumberyard、O3DE的关系</title>
    <link href="https://blog.kdyx.net/blog/kongdeyou/the_relationship_of_cryengine_lumberyard_o3de/"/>
    <id>https://blog.kdyx.net/blog/kongdeyou/the_relationship_of_cryengine_lumberyard_o3de/</id>
    <published>2021-07-23T11:23:00.000Z</published>
    <updated>2024-04-04T03:53:39.524Z</updated>
    
    <content type="html"><![CDATA[<p>七月中旬，O3DE开源了，这一大家子齐活了。</p><p>它们仨的关系，差不多算得上是套娃。CryTek在快不行的时候，把CryEngine3卖给了AWS，拿了一笔钱，然后大重构出了CryEngine5。AWS封装魔改CryEngine3做出了一个Lumberyard，Lumberyard没有盘活（星际公民难产到现在还生不出来），然后AWS就几乎把这个项目割了。O3DE目前是开源组织维护的，他们把Lumberyard拿了过来，疯狂重构衍生出了O3DE，同时Lumberyard并没有就此尘封，还在慢腾腾地往前更新。</p><p>21世纪10年代的时候，游戏如日中天地发展，亚马逊也想插足一脚进来，但是亚马逊是做云平台起家的，思维方式和做游戏的完全不一样，亚马逊想把游戏引擎架设在它自家的云上，这大概是最早的云游戏思想了吧。亚马逊本身此时对游戏引擎的开发是没有技术积累的，而亚马逊最核心的需求也不在于游戏引擎本身的技术而在于用游戏来推广它自家的云服务器，因此收购一个当时现有的引擎，在上面改造就成了最快的解决方案，但是选了一个会让人哭的引擎，就算是亚马逊，也没能把它整笑，还差点把自己给玩死了。难怪大家吐槽，亚马逊的最大贡献，就是开源了CryEngine3的源码。</p><p>在亚马逊拿着Lumberyard快玩不下去的时候，O3DE站了出来，原先Lumberyard的大批人马，走的走、到O3DE的到了O3DE，还留在Lumberyard的所剩无几了。随后O3DE开始在这上面重构，首先重构了Lumberyard操蛋的构建方式，这年头基本没人会选WAF做构建，用WAF在Lumberyard里加个东西相当要命，另外Lumberyard的编译如果没有IncrediBuild支持，那能耗上5个小时，而且它自己提供的脚本还只有全部clean和全部build，预编译了一堆头，改点底层的东西想调试，就得全部重新编译一趟，十分操蛋，另外Lumberyard还有一些模块间的依赖关系没有指明清楚，导致IncrediBuild加速编译的时候有时候编一半会出错，重新再编译一次又正常了（没明确定义好依赖关系，会让IncrediBuild对项目生成的依赖关系图出现问题，放到多个agent上并行编译的时候，依赖的模块放在了另一个agent上还没生成出来，重新再编译一次时，在当前基础上增量构建让IncrediBuild重新生成了顺序，这个问题就不出现了）。当然Lumberyard也不是一无是处，Gems模块化的思路，通讯组件等等这些做的都非常好，毕竟这些才是AWS拿手的东西嘛。O3DE明智地选择了大家熟悉的CMake，把框架依赖全部撸了一遍，增量编译都变得容易了不少。然后O3DE几乎摒弃了CryEngine，开始自己重写游戏引擎渲染模块Atom，我认同重写的需要，只有自己的东西才有完全的掌控力，尤其是游戏引擎（但是不代表所有的都要重写，比如标准库就完全没有必要，亚马逊没有重写游戏引擎，居然重写了一套标准库AZStd，用来替换C++的STL，我没明白为啥要这么做。掌控力应该是掌控核心产品的实现方法，而不是所有的东西，何况是一个标准库，而且Lumberyard里面还写了三套序列化库…阿西巴）。周边的游戏功能还是继承Lumberyard的设计，以Gems插件化的形式加进来，这种策略也是正确的，模块化和按需动态加载能应对各种扩展需求。</p><p>总的来说，O3DE让我看到了一点盘活的希望，目前来说是取其精华去其糟粕的重构，希望O3DE能逐渐做出点东西来~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;七月中旬，O3DE开源了，这一大家子齐活了。&lt;/p&gt;
&lt;p&gt;它们仨的关系，差不多算得上是套娃。CryTek在快不行的时候，把CryEngine3卖给了AWS，拿了一笔钱，然后大重构出了CryEngine5。AWS封装魔改CryEngine3做出了一个Lumberyard，L</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>未定义的类不允许作为编译器内部类型特征“__is_destructible”的参数--问题解决记录</title>
    <link href="https://blog.kdyx.net/blog/kongdeyou/the_error_of_future_is_destructible/"/>
    <id>https://blog.kdyx.net/blog/kongdeyou/the_error_of_future_is_destructible/</id>
    <published>2021-07-21T15:04:00.000Z</published>
    <updated>2024-04-04T03:53:39.524Z</updated>
    
    <content type="html"><![CDATA[<p>最近升级了Visual Studio 2019的小版本，MSVC升级到了14.29.30037，然后导致了原先编译正常的Lumberyard代码，现在报出了如下错误：</p><pre><code class="language-text  line-numbers">...\2019\Community\VC\Tools\MSVC\14.29.30037\include\type_traits(736,28): error C2139: “OutcomeCallable”: 未定义的类不允许作为编译器内部类型特征“__is_destructible”的参数【此处省略中间一大串模板栈展开的报错信息】...\2019\Community\VC\Tools\MSVC\14.29.30037\include\future(880,56): error C2338: T in future&lt;T&gt; must meet the Cpp17Destructible requirements (N4878 [futures.unique.future]/4).</code></pre><p>全网搜不到现成的解决方案，只好自己分析啦（顺便写篇博客记录一下）。</p><p>首先看了下错误栈最底下的future的880行，对比之前的版本和最新的版本：</p><pre><code class="language-cpp  line-numbers">template &lt;class _Ty&gt;class future : public _State_manager&lt;_Ty&gt; &#123;...    static_assert(!is_array_v&lt;_Ty&gt; &amp;&amp; is_object_v&lt;_Ty&gt;,        "T in future&lt;T&gt; must meet the Cpp17Destructible requirements (N4878 [futures.unique.future]/4).");...&#125;</code></pre><pre><code class="language-cpp  line-numbers">template &lt;class _Ty&gt;class future : public _State_manager&lt;_Ty&gt; &#123;...    static_assert(!is_array_v&lt;_Ty&gt; &amp;&amp; is_object_v&lt;_Ty&gt; &amp;&amp; is_destructible_v&lt;_Ty&gt;,        "T in future&lt;T&gt; must meet the Cpp17Destructible requirements (N4878 [futures.unique.future]/4).");...&#125;</code></pre><p>新版本多了一个is_destructible_v&lt;_Ty&gt;。</p><p>在结合最顶层的错误信息，上微软官方文档查了<a href="https://docs.microsoft.com/en-us/cpp/error-messages/compiler-errors-1/compiler-error-c2139?view=msvc-160">error C2139</a>的错误描述，通过分析官方文档上的示例，确定是类型只有声明没有定义时会报出这个错误。</p><p>因此，前面的问题的答案是，在is_destructible_v给_Ty类型时，只有声明，没有定义，往future里头套回去，就是在声明一个future<T>变量时，T还只是声明，没有定义，一般这种情况是<strong>少包含了类定义的头文件</strong>。</p><p>做一个简单的示例来复现一下这个错误，发现报出了同样的问题（实锤）。</p><pre><code class="language-cpp  line-numbers">#include &lt;future&gt;class A;int main()&#123;    std::future&lt;A&gt; a;&#125;</code></pre><p>回到Lumberyard的代码里，分析代码缺的头文件，加上后问题解决。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近升级了Visual Studio 2019的小版本，MSVC升级到了14.29.30037，然后导致了原先编译正常的Lumberyard代码，现在报出了如下错误：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-text  line-numbers&quot;&gt;..</summary>
      
    
    
    
    
  </entry>
  
</feed>
